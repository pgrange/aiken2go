package blueprint

import (
	"fmt"
	"sort"
	"strings"
	"unicode"
)

// GeneratorOptions configures the code generator.
type GeneratorOptions struct {
	// PackageName is the Go package name for generated code.
	PackageName string
}

// Generator produces Go source code from a Blueprint.
type Generator struct {
	bp         *Blueprint
	opts       GeneratorOptions
	buf        strings.Builder
	indent     int
	generated  map[string]bool // track which types have been generated
}

// NewGenerator creates a new code generator.
func NewGenerator(bp *Blueprint, opts GeneratorOptions) *Generator {
	if opts.PackageName == "" {
		opts.PackageName = "contracts"
	}
	return &Generator{
		bp:        bp,
		opts:      opts,
		generated: make(map[string]bool),
	}
}

// Generate produces Go source code from the blueprint.
func (g *Generator) Generate() (string, error) {
	g.writeHeader()
	g.writeImports()
	g.writeLine("")

	// Generate type definitions
	if err := g.writeTypeDefinitions(); err != nil {
		return "", err
	}

	return g.buf.String(), nil
}

func (g *Generator) writeHeader() {
	g.writeLine("// Code generated by aiken2go. DO NOT EDIT.")
	g.writeLine(fmt.Sprintf("// Source: %s", g.bp.Preamble.Title))
	g.writeLine("")
	g.writeLine(fmt.Sprintf("package %s", g.opts.PackageName))
}

func (g *Generator) writeImports() {
	g.writeLine("")
	g.writeLine("import (")
	g.indentInc()
	g.writeLine(`"bytes"`)
	g.writeLine(`"errors"`)
	g.writeLine(`"fmt"`)
	g.writeLine(`"math/big"`)
	if g.hasMaps() {
		g.writeLine(`"reflect"`)
	}
	g.writeLine("")
	g.writeLine(`"github.com/fxamacker/cbor/v2"`)
	g.indentDec()
	g.writeLine(")")
	g.writeLine("")
	g.writePlutusDataTypes()
	g.writeHelpers()
}

func (g *Generator) hasMaps() bool {
	for name := range g.bp.Definitions {
		if strings.HasPrefix(name, "Pairs$") {
			return true
		}
	}
	// Also check for inline map schemas
	for _, schema := range g.bp.Definitions {
		if schema.IsMap() {
			return true
		}
		if schema.IsEnum() {
			for _, variant := range schema.AnyOf {
				for _, field := range variant.Fields {
					if field.IsMap() || (field.IsRef() && strings.HasPrefix(field.RefName(), "Pairs$")) {
						return true
					}
				}
			}
		}
	}
	return false
}

func (g *Generator) writePlutusDataTypes() {
	// PlutusData types - embedded directly in generated code
	g.writeLine("// PlutusData represents a Plutus Data value that can be serialized to CBOR.")
	g.writeLine("type PlutusData struct {")
	g.indentInc()
	g.writeLine("Constr     *ConstrPlutusData")
	g.writeLine("Integer    *big.Int")
	g.writeLine("ByteString []byte")
	g.writeLine("List       []PlutusData")
	g.writeLine("Map        []PlutusDataMapEntry")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// ConstrPlutusData represents a constructor with an index and fields.")
	g.writeLine("type ConstrPlutusData struct {")
	g.indentInc()
	g.writeLine("Index  uint64")
	g.writeLine("Fields []PlutusData")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// PlutusDataMapEntry represents a key-value pair in a Plutus Data map.")
	g.writeLine("type PlutusDataMapEntry struct {")
	g.indentInc()
	g.writeLine("Key   PlutusData")
	g.writeLine("Value PlutusData")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Constants
	g.writeLine("const (")
	g.indentInc()
	g.writeLine("cborTagConstr0    = 121")
	g.writeLine("cborTagConstr6    = 127")
	g.writeLine("cborTagConstrBase = 1280")
	g.indentDec()
	g.writeLine(")")
	g.writeLine("")

	// Constructor functions
	g.writeLine("// NewConstrPlutusData creates a new constructor PlutusData.")
	g.writeLine("func NewConstrPlutusData(index uint64, fields ...PlutusData) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{Constr: &ConstrPlutusData{Index: index, Fields: fields}}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// NewIntPlutusData creates a new integer PlutusData.")
	g.writeLine("func NewIntPlutusData(i *big.Int) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: i}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// NewBytesPlutusData creates a new bytestring PlutusData.")
	g.writeLine("func NewBytesPlutusData(b []byte) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{ByteString: b}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// NewListPlutusData creates a new list PlutusData.")
	g.writeLine("func NewListPlutusData(items ...PlutusData) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{List: items}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// NewMapPlutusData creates a new map PlutusData.")
	g.writeLine("func NewMapPlutusData(entries ...PlutusDataMapEntry) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{Map: entries}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// MarshalCBOR - uses indefinite-length arrays to match Aiken's CBOR format
	g.writeLine("// MarshalCBOR serializes PlutusData to CBOR bytes using indefinite-length arrays.")
	g.writeLine("func (p PlutusData) MarshalCBOR() ([]byte, error) {")
	g.indentInc()
	g.writeLine("return p.toCBORBytes()")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// UnmarshalCBOR
	g.writeLine("// UnmarshalCBOR deserializes PlutusData from CBOR bytes.")
	g.writeLine("func (p *PlutusData) UnmarshalCBOR(data []byte) error {")
	g.indentInc()
	g.writeLine("dm, err := cbor.DecOptions{BigIntDec: cbor.BigIntDecodePointer}.DecMode()")
	g.writeLine("if err != nil { return err }")
	g.writeLine("var raw interface{}")
	g.writeLine("if err := dm.Unmarshal(data, &raw); err != nil { return err }")
	g.writeLine("result, err := plutusDataFromCBORValue(raw)")
	g.writeLine("if err != nil { return err }")
	g.writeLine("*p = result")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// toCBORBytes - produces CBOR bytes with indefinite-length arrays (Aiken format)
	g.writeLine("func (p PlutusData) toCBORBytes() ([]byte, error) {")
	g.indentInc()
	g.writeLine("em, err := cbor.EncOptions{BigIntConvert: cbor.BigIntConvertShortest}.EncMode()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("switch {")
	g.writeLine("case p.Constr != nil:")
	g.indentInc()
	g.writeLine("var buf bytes.Buffer")
	g.writeLine("// Encode constructor tag")
	g.writeLine("var tag uint64")
	g.writeLine("if p.Constr.Index <= 6 { tag = cborTagConstr0 + p.Constr.Index } else { tag = cborTagConstrBase + p.Constr.Index - 7 }")
	g.writeLine("// Write CBOR tag header (minimal encoding)")
	g.writeLine("if tag < 24 { buf.WriteByte(0xc0 + byte(tag)) } else if tag < 256 { buf.WriteByte(0xd8); buf.WriteByte(byte(tag)) } else { buf.WriteByte(0xd9); buf.WriteByte(byte(tag >> 8)); buf.WriteByte(byte(tag)) }")
	g.writeLine("// Empty arrays use definite-length encoding, non-empty use indefinite")
	g.writeLine("if len(p.Constr.Fields) == 0 {")
	g.indentInc()
	g.writeLine("buf.WriteByte(0x80) // empty array")
	g.indentDec()
	g.writeLine("} else {")
	g.indentInc()
	g.writeLine("buf.WriteByte(0x9f) // indefinite-length array start")
	g.writeLine("for _, f := range p.Constr.Fields {")
	g.indentInc()
	g.writeLine("fieldBytes, err := f.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(fieldBytes)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("buf.WriteByte(0xff) // break")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return buf.Bytes(), nil")
	g.indentDec()
	g.writeLine("case p.Integer != nil:")
	g.indentInc()
	g.writeLine("return em.Marshal(p.Integer)")
	g.indentDec()
	g.writeLine("case p.ByteString != nil:")
	g.indentInc()
	g.writeLine("return em.Marshal(p.ByteString)")
	g.indentDec()
	g.writeLine("case p.List != nil:")
	g.indentInc()
	g.writeLine("var buf bytes.Buffer")
	g.writeLine("// Write indefinite-length array start")
	g.writeLine("buf.WriteByte(0x9f)")
	g.writeLine("for _, item := range p.List {")
	g.indentInc()
	g.writeLine("itemBytes, err := item.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(itemBytes)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("// Write indefinite-length array end (break)")
	g.writeLine("buf.WriteByte(0xff)")
	g.writeLine("return buf.Bytes(), nil")
	g.indentDec()
	g.writeLine("case p.Map != nil:")
	g.indentInc()
	g.writeLine("var buf bytes.Buffer")
	g.writeLine("// Empty maps use definite-length, non-empty use indefinite")
	g.writeLine("if len(p.Map) == 0 {")
	g.indentInc()
	g.writeLine("buf.WriteByte(0xa0) // empty map (definite-length)")
	g.indentDec()
	g.writeLine("} else {")
	g.indentInc()
	g.writeLine("buf.WriteByte(0xbf) // indefinite-length map start")
	g.writeLine("for _, entry := range p.Map {")
	g.indentInc()
	g.writeLine("keyBytes, err := entry.Key.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(keyBytes)")
	g.writeLine("valBytes, err := entry.Value.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(valBytes)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("buf.WriteByte(0xff) // break")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return buf.Bytes(), nil")
	g.indentDec()
	g.writeLine("default:")
	g.indentInc()
	g.writeLine("// Empty constructor 0")
	g.writeLine("return []byte{0xd8, 0x79, 0x9f, 0xff}, nil")
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// fromCBORValue
	g.writeLine("func plutusDataFromCBORValue(v interface{}) (PlutusData, error) {")
	g.indentInc()
	g.writeLine("switch val := v.(type) {")
	g.writeLine("case cbor.Tag:")
	g.indentInc()
	g.writeLine("var index uint64")
	g.writeLine("switch {")
	g.writeLine("case val.Number >= cborTagConstr0 && val.Number <= cborTagConstr6: index = val.Number - cborTagConstr0")
	g.writeLine("case val.Number >= cborTagConstrBase: index = val.Number - cborTagConstrBase + 7")
	g.writeLine(`default: return PlutusData{}, fmt.Errorf("unsupported CBOR tag: %d", val.Number)`)
	g.writeLine("}")
	g.writeLine("content, ok := val.Content.([]interface{}); if !ok { return PlutusData{}, errors.New(\"constructor content is not an array\") }")
	g.writeLine("fields := make([]PlutusData, len(content))")
	g.writeLine("for i, item := range content { pd, err := plutusDataFromCBORValue(item); if err != nil { return PlutusData{}, err }; fields[i] = pd }")
	g.writeLine("return PlutusData{Constr: &ConstrPlutusData{Index: index, Fields: fields}}, nil")
	g.indentDec()
	g.writeLine("case *big.Int:")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: val}, nil")
	g.indentDec()
	g.writeLine("case int64:")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: big.NewInt(val)}, nil")
	g.indentDec()
	g.writeLine("case uint64:")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: new(big.Int).SetUint64(val)}, nil")
	g.indentDec()
	g.writeLine("case []byte:")
	g.indentInc()
	g.writeLine("return PlutusData{ByteString: val}, nil")
	g.indentDec()
	g.writeLine("case cbor.ByteString:")
	g.indentInc()
	g.writeLine("return PlutusData{ByteString: []byte(val)}, nil")
	g.indentDec()
	g.writeLine("case []interface{}:")
	g.indentInc()
	g.writeLine("items := make([]PlutusData, len(val))")
	g.writeLine("for i, item := range val { pd, err := plutusDataFromCBORValue(item); if err != nil { return PlutusData{}, err }; items[i] = pd }")
	g.writeLine("return PlutusData{List: items}, nil")
	g.indentDec()
	g.writeLine("case map[interface{}]interface{}:")
	g.indentInc()
	g.writeLine("entries := make([]PlutusDataMapEntry, 0, len(val))")
	g.writeLine("for k, v := range val {")
	g.indentInc()
	g.writeLine("key, err := plutusDataFromCBORValue(k); if err != nil { return PlutusData{}, err }")
	g.writeLine("value, err := plutusDataFromCBORValue(v); if err != nil { return PlutusData{}, err }")
	g.writeLine("entries = append(entries, PlutusDataMapEntry{Key: key, Value: value})")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return PlutusData{Map: entries}, nil")
	g.indentDec()
	g.writeLine("case nil:")
	g.indentInc()
	g.writeLine("// CBOR null - not standard PlutusData, but some serializers use it")
	g.writeLine("// Treat as Void/Unit (constructor 0 with no fields)")
	g.writeLine("return PlutusData{Constr: &ConstrPlutusData{Index: 0, Fields: []PlutusData{}}}, nil")
	g.indentDec()
	g.writeLine("default:")
	g.indentInc()
	g.writeLine(`return PlutusData{}, fmt.Errorf("unsupported CBOR type: %T", v)`)
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// ToHex
	g.writeLine("// ToHex returns the CBOR encoding as a hex string.")
	g.writeLine("func (p PlutusData) ToHex() (string, error) {")
	g.indentInc()
	g.writeLine("data, err := p.MarshalCBOR(); if err != nil { return \"\", err }")
	g.writeLine("return fmt.Sprintf(\"%x\", data), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Equals
	g.writeLine("// Equals compares two PlutusData values for equality.")
	g.writeLine("func (p PlutusData) Equals(other PlutusData) bool {")
	g.indentInc()
	g.writeLine("a, err := p.MarshalCBOR(); if err != nil { return false }")
	g.writeLine("b, err := other.MarshalCBOR(); if err != nil { return false }")
	g.writeLine("return bytes.Equal(a, b)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeHelpers() {
	// plutusDataTypeString helper - describes the type of a PlutusData for error messages
	g.writeLine("func plutusDataTypeString(pd PlutusData) string {")
	g.indentInc()
	g.writeLine("switch {")
	g.writeLine("case pd.Constr != nil:")
	g.indentInc()
	g.writeLine(`return fmt.Sprintf("constructor(%d)", pd.Constr.Index)`)
	g.indentDec()
	g.writeLine("case pd.Integer != nil:")
	g.indentInc()
	g.writeLine(`return "integer"`)
	g.indentDec()
	g.writeLine("case pd.ByteString != nil:")
	g.indentInc()
	g.writeLine(`return "bytes"`)
	g.indentDec()
	g.writeLine("case pd.List != nil:")
	g.indentInc()
	g.writeLine(`return "list"`)
	g.indentDec()
	g.writeLine("case pd.Map != nil:")
	g.indentInc()
	g.writeLine(`return "map"`)
	g.indentDec()
	g.writeLine("default:")
	g.indentInc()
	g.writeLine(`return "null"`)
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Suppress unused variable warnings
	g.writeLine("var _ = errors.New")
	g.writeLine("var _ = big.NewInt")
	g.writeLine("var _ = PlutusData{}")
}

func (g *Generator) writeTypeDefinitions() error {
	// Sort definition names for deterministic output
	names := make([]string, 0, len(g.bp.Definitions))
	for name := range g.bp.Definitions {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		schema := g.bp.Definitions[name]
		if g.isStandardTypeName(name) {
			continue
		}
		// Skip List$ and Pairs$ types as they're handled inline
		// But generate Tuple$ types as structs
		if strings.HasPrefix(name, "List$") || strings.HasPrefix(name, "Pairs$") {
			continue
		}
		if err := g.writeTypeDef(name, schema); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) writeTypeDef(name string, schema *Schema) error {
	goName := g.normalizeTypeName(name)

	// Skip if already generated
	if g.generated[goName] {
		return nil
	}

	// Handle different schema types
	// Only mark as generated AFTER we confirm we will generate something
	switch {
	case schema.IsBoolean():
		// Generate Bool enum type with BoolFromPlutusData
		g.generated[goName] = true
		return g.writeBoolType(goName, schema)
	case schema.IsUnit():
		// Generate empty struct for Unit/Void
		g.generated[goName] = true
		g.writeUnitType(goName)
		return nil
	case schema.IsOption():
		// Generate Option type with IsSet + Value
		g.generated[goName] = true
		return g.writeOptionType(goName, schema)
	case schema.IsSingleConstructor():
		// Single constructor - generate struct
		g.generated[goName] = true
		return g.writeStructType(goName, &schema.AnyOf[0], 0)
	case schema.IsEnum():
		// Multiple constructors - generate interface + variants
		g.generated[goName] = true
		return g.writeEnumType(goName, schema)
	case schema.IsConstructor():
		// Direct constructor
		g.generated[goName] = true
		return g.writeStructType(goName, schema, 0)
	case schema.IsList() && len(schema.Items) > 1:
		// Tuple type (list with multiple items)
		g.generated[goName] = true
		return g.writeTupleType(goName, schema)
	case schema.IsList() && len(schema.Items) == 1:
		// Named list type (single item) - generate type alias
		g.generated[goName] = true
		return g.writeListTypeAlias(goName, schema)
	default:
		// Primitive or reference - skip (handled inline)
		// Don't mark as generated since we're not generating anything
		return nil
	}
}

func (g *Generator) writeUnitType(name string) {
	g.writeLine(fmt.Sprintf("// %s represents the Aiken Void/Unit type.", name))
	g.writeLine(fmt.Sprintf("type %s struct{}", name))
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine("return NewConstrPlutusData(0), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(`return errors.New("expected constructor for Unit type")`)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if pd.Constr.Index != 0 {")
	g.indentInc()
	g.writeLine(`return fmt.Errorf("wrong constructor index for Unit type: expected 0, got %d", pd.Constr.Index)`)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if len(pd.Constr.Fields) != 0 {")
	g.indentInc()
	g.writeLine(`return fmt.Errorf("wrong number of fields for Unit type: expected 0, got %d", len(pd.Constr.Fields))`)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeOptionType(name string, schema *Schema) error {
	// Option is an enum with Some (0) and None (1) constructors
	// Get the inner type from the Some variant
	innerType := "interface{}"
	if len(schema.AnyOf) > 0 && len(schema.AnyOf[0].Fields) > 0 {
		innerType = g.schemaToGoType(&schema.AnyOf[0].Fields[0])
	}

	g.writeLine(fmt.Sprintf("// %s represents an optional %s value.", name, innerType))
	g.writeLine(fmt.Sprintf("type %s struct {", name))
	g.indentInc()
	g.writeLine(fmt.Sprintf("Value %s", innerType))
	g.writeLine("IsSet bool")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine("if !v.IsSet {")
	g.indentInc()
	g.writeLine("return NewConstrPlutusData(1), nil // None")
	g.indentDec()
	g.writeLine("}")
	// Generate inner serialization based on type
	g.writeOptionInnerToPlutusData(name, innerType, schema)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData method
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if pd.Constr.Index == 1 { // None")
	g.indentInc()
	g.writeLine("v.IsSet = false")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if pd.Constr.Index != 0 {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("unknown constructor index for %s: got %%d (expected 0 for Some or 1 for None)", pd.Constr.Index)`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if len(pd.Constr.Fields) != 1 {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong number of fields for %s Some: expected 1, got %%d", len(pd.Constr.Fields))`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("v.IsSet = true")
	// Generate inner deserialization
	g.writeOptionInnerFromPlutusData(name, innerType, schema)
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData function
	g.writeLine(fmt.Sprintf("// %sFromPlutusData decodes a %s from PlutusData.", name, name))
	g.writeLine(fmt.Sprintf("func %sFromPlutusData(pd PlutusData) (%s, error) {", name, name))
	g.indentInc()
	g.writeLine(fmt.Sprintf("var v %s", name))
	g.writeLine("if err := v.FromPlutusData(pd); err != nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf("return %s{}, err", name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return v, nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Equals method
	g.writeOptionEquals(name, schema)

	return nil
}

func (g *Generator) writeOptionInnerToPlutusData(optionName, innerType string, schema *Schema) {
	// Get the actual inner schema
	var innerSchema *Schema
	if len(schema.AnyOf) > 0 && len(schema.AnyOf[0].Fields) > 0 {
		innerSchema = &schema.AnyOf[0].Fields[0]
	}

	if innerSchema != nil && innerSchema.IsRef() {
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("return NewConstrPlutusData(0, NewIntPlutusData(v.Value)), nil")
			return
		case "ByteArray":
			g.writeLine("return NewConstrPlutusData(0, NewBytesPlutusData(v.Value)), nil")
			return
		case "Data":
			g.writeLine("return NewConstrPlutusData(0, v.Value), nil")
			return
		default:
			// Check if it's a primitive wrapper
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("return NewConstrPlutusData(0, NewBytesPlutusData(v.Value)), nil")
				return
			}
			if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("return NewConstrPlutusData(0, NewIntPlutusData(v.Value)), nil")
				return
			}
		}
	}

	if innerSchema != nil && innerSchema.IsInteger() {
		g.writeLine("return NewConstrPlutusData(0, NewIntPlutusData(v.Value)), nil")
		return
	}

	if innerSchema != nil && innerSchema.IsBytes() {
		g.writeLine("return NewConstrPlutusData(0, NewBytesPlutusData(v.Value)), nil")
		return
	}

	// Complex inner type
	// Check if it's an enum (interface) that could be nil
	if innerSchema != nil && innerSchema.IsRef() {
		refName := innerSchema.RefName()
		if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
			g.writeLine("if v.Value == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("%s.Value: value is nil (expected %s)")`, optionName, g.normalizeTypeName(refName)))
			g.indentDec()
			g.writeLine("}")
		}
	}
	g.writeLine("innerPd, err := v.Value.ToPlutusData()")
	g.writeLine("if err != nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("%s.Value: %%w", err)`, optionName))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return NewConstrPlutusData(0, innerPd), nil")
}

func (g *Generator) writeOptionInnerFromPlutusData(optionName, innerType string, schema *Schema) {
	// Get the actual inner schema
	var innerSchema *Schema
	if len(schema.AnyOf) > 0 && len(schema.AnyOf[0].Fields) > 0 {
		innerSchema = &schema.AnyOf[0].Fields[0]
	}

	if innerSchema != nil && innerSchema.IsRef() {
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected integer for Some value, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, optionName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
			return
		case "ByteArray":
			g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected bytes for Some value, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, optionName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
			return
		case "Data":
			g.writeLine("v.Value = pd.Constr.Fields[0]")
			return
		default:
			// Check if it's a primitive wrapper
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected bytes for Some value, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, optionName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
				return
			}
			if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected integer for Some value, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, optionName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
				return
			}
		}
	}

	if innerSchema != nil && innerSchema.IsInteger() {
		g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected integer for Some value, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, optionName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
		return
	}

	if innerSchema != nil && innerSchema.IsBytes() {
		g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected bytes for Some value, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, optionName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
		return
	}

	// Complex inner type - check if it's an enum
	if innerSchema != nil && innerSchema.IsRef() {
		refName := innerSchema.RefName()
		unescaped := g.unescapeRef(refName)
		if def, ok := g.bp.Definitions[unescaped]; ok && def.IsEnum() && !def.IsSingleConstructor() {
			// Enum type - use factory function
			typeName := g.normalizeTypeName(refName)
			g.writeLine(fmt.Sprintf("innerVal, err := %sFromPlutusData(pd.Constr.Fields[0])", typeName))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: %%w", err)`, optionName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("v.Value = innerVal")
			return
		}
	}

	// Non-enum complex type
	g.writeLine("if err := v.Value.FromPlutusData(pd.Constr.Fields[0]); err != nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: %%w", err)`, optionName))
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeOptionEquals(name string, schema *Schema) {
	g.writeLine(fmt.Sprintf("func (v %s) Equals(other %s) bool {", name, name))
	g.indentInc()
	g.writeLine("if v.IsSet != other.IsSet {")
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if !v.IsSet {")
	g.indentInc()
	g.writeLine("return true // Both are None")
	g.indentDec()
	g.writeLine("}")

	// Get the actual inner schema
	var innerSchema *Schema
	if len(schema.AnyOf) > 0 && len(schema.AnyOf[0].Fields) > 0 {
		innerSchema = &schema.AnyOf[0].Fields[0]
	}

	if innerSchema != nil && innerSchema.IsRef() {
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("if v.Value == nil && other.Value == nil {")
			g.indentInc()
			g.writeLine("return true")
			g.indentDec()
			g.writeLine("}")
			g.writeLine("if v.Value == nil || other.Value == nil {")
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
			g.writeLine("return v.Value.Cmp(other.Value) == 0")
		case "ByteArray":
			g.writeLine("return bytes.Equal(v.Value, other.Value)")
		case "Data":
			g.writeLine("return v.Value.Equals(other.Value)")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("return bytes.Equal(v.Value, other.Value)")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if v.Value == nil && other.Value == nil {")
				g.indentInc()
				g.writeLine("return true")
				g.indentDec()
				g.writeLine("}")
				g.writeLine("if v.Value == nil || other.Value == nil {")
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
				g.writeLine("return v.Value.Cmp(other.Value) == 0")
			} else if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
				typeName := g.normalizeTypeName(refName)
				g.writeLine(fmt.Sprintf("return %sEquals(v.Value, other.Value)", typeName))
			} else {
				g.writeLine("return v.Value.Equals(other.Value)")
			}
		}
	} else if innerSchema != nil && innerSchema.IsInteger() {
		g.writeLine("if v.Value == nil && other.Value == nil {")
		g.indentInc()
		g.writeLine("return true")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("if v.Value == nil || other.Value == nil {")
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("return v.Value.Cmp(other.Value) == 0")
	} else if innerSchema != nil && innerSchema.IsBytes() {
		g.writeLine("return bytes.Equal(v.Value, other.Value)")
	} else {
		g.writeLine("return v.Value.Equals(other.Value)")
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeBoolType(name string, _ *Schema) error {
	// Bool is an enum with False (0) and True (1) constructors
	g.writeLine(fmt.Sprintf("// %s represents the Aiken Bool type.", name))
	g.writeLine(fmt.Sprintf("type %s bool", name))
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine("if v {")
	g.indentInc()
	g.writeLine("return NewConstrPlutusData(1), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return NewConstrPlutusData(0), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData method
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("*v = pd.Constr.Index == 1")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData function
	g.writeLine(fmt.Sprintf("// %sFromPlutusData decodes a %s from PlutusData.", name, name))
	g.writeLine(fmt.Sprintf("func %sFromPlutusData(pd PlutusData) (%s, error) {", name, name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return false, errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("return %s(pd.Constr.Index == 1), nil", name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	return nil
}

func (g *Generator) writeStructType(name string, schema *Schema, constrIndex int) error {
	// Documentation
	if schema.Title != "" {
		g.writeLine(fmt.Sprintf("// %s represents the Aiken %s type.", name, schema.Title))
	}

	// Struct definition
	g.writeLine(fmt.Sprintf("type %s struct {", name))
	g.indentInc()

	for i, field := range schema.Fields {
		fieldName := g.normalizeFieldName(field.Title, i)
		fieldType := g.schemaToGoType(&field)
		g.writeLine(fmt.Sprintf("%s %s", fieldName, fieldType))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Generate ToPlutusData method
	g.writeStructToPlutusData(name, schema, constrIndex)

	// Generate FromPlutusData method
	g.writeStructFromPlutusData(name, schema, constrIndex)

	// Generate Equals method
	g.writeStructEquals(name, schema)

	return nil
}

func (g *Generator) writeStructEquals(name string, schema *Schema) {
	g.writeLine(fmt.Sprintf("func (v %s) Equals(other %s) bool {", name, name))
	g.indentInc()

	if len(schema.Fields) == 0 {
		g.writeLine("return true")
	} else {
		for i, field := range schema.Fields {
			fieldName := g.normalizeFieldName(field.Title, i)
			g.writeFieldEquals(fieldName, &field)
		}
		g.writeLine("return true")
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeFieldEquals(fieldName string, schema *Schema) {
	switch {
	case schema.IsRef():
		refName := schema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("if v.%s == nil && other.%s == nil {", fieldName, fieldName))
			g.writeLine(fmt.Sprintf("} else if v.%s == nil || other.%s == nil || v.%s.Cmp(other.%s) != 0 {", fieldName, fieldName, fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		case "ByteArray":
			g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s, other.%s) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		case "Bool":
			g.writeLine(fmt.Sprintf("if v.%s != other.%s {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		case "Data":
			// Data type is PlutusData - use its Equals method
			g.writeLine(fmt.Sprintf("if !v.%s.Equals(other.%s) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		default:
			if strings.HasPrefix(refName, "List$") {
				g.writeListFieldEquals(fieldName, refName)
			} else if strings.HasPrefix(refName, "Pairs$") {
				// Map type - use reflect.DeepEqual
				g.writeLine(fmt.Sprintf("if !reflect.DeepEqual(v.%s, other.%s) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else if strings.HasPrefix(refName, "Option$") {
				g.writeOptionFieldEquals(fieldName, refName)
			} else if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s, other.%s) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("if v.%s == nil && other.%s == nil {", fieldName, fieldName))
				g.writeLine(fmt.Sprintf("} else if v.%s == nil || other.%s == nil || v.%s.Cmp(other.%s) != 0 {", fieldName, fieldName, fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else {
				// Check if it's an enum type (interface)
				if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					typeName := g.normalizeTypeName(refName)
					g.writeLine(fmt.Sprintf("if !%sEquals(v.%s, other.%s) {", typeName, fieldName, fieldName))
					g.indentInc()
					g.writeLine("return false")
					g.indentDec()
					g.writeLine("}")
				} else {
					// Struct type with Equals method
					g.writeLine(fmt.Sprintf("if !v.%s.Equals(other.%s) {", fieldName, fieldName))
					g.indentInc()
					g.writeLine("return false")
					g.indentDec()
					g.writeLine("}")
				}
			}
		}
	case schema.IsInteger():
		g.writeLine(fmt.Sprintf("if v.%s == nil && other.%s == nil {", fieldName, fieldName))
		g.writeLine(fmt.Sprintf("} else if v.%s == nil || other.%s == nil || v.%s.Cmp(other.%s) != 0 {", fieldName, fieldName, fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case schema.IsBytes():
		g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s, other.%s) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case schema.IsList():
		g.writeInlineListFieldEquals(fieldName, schema)
	case schema.IsMap():
		// Map type - use reflect.DeepEqual
		g.writeLine(fmt.Sprintf("if !reflect.DeepEqual(v.%s, other.%s) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case schema.IsBoolean():
		g.writeLine(fmt.Sprintf("if v.%s != other.%s {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case schema.IsOption():
		g.writeInlineOptionFieldEquals(fieldName, schema)
	default:
		// Try struct equals
		g.writeLine(fmt.Sprintf("if !v.%s.Equals(other.%s) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeListFieldEquals(fieldName string, refName string) {
	inner := strings.TrimPrefix(refName, "List$")
	inner = strings.ReplaceAll(inner, "~1", "/")

	g.writeLine(fmt.Sprintf("if len(v.%s) != len(other.%s) {", fieldName, fieldName))
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("for i := range v.%s {", fieldName))
	g.indentInc()

	switch inner {
	case "Int":
		g.writeLine(fmt.Sprintf("if v.%s[i] == nil && other.%s[i] == nil {", fieldName, fieldName))
		g.writeLine(fmt.Sprintf("} else if v.%s[i] == nil || other.%s[i] == nil || v.%s[i].Cmp(other.%s[i]) != 0 {", fieldName, fieldName, fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case "ByteArray":
		g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s[i], other.%s[i]) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case "Bool":
		g.writeLine(fmt.Sprintf("if v.%s[i] != other.%s[i] {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	default:
		if g.isPrimitiveWrapper(inner, "bytes") {
			g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s[i], other.%s[i]) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		} else if g.isPrimitiveWrapper(inner, "integer") {
			g.writeLine(fmt.Sprintf("if v.%s[i] == nil && other.%s[i] == nil {", fieldName, fieldName))
			g.writeLine(fmt.Sprintf("} else if v.%s[i] == nil || other.%s[i] == nil || v.%s[i].Cmp(other.%s[i]) != 0 {", fieldName, fieldName, fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		} else {
			// Check if enum
			if defSchema, ok := g.bp.Definitions[g.unescapeRef(inner)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
				typeName := g.normalizeTypeName(inner)
				g.writeLine(fmt.Sprintf("if !%sEquals(v.%s[i], other.%s[i]) {", typeName, fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else {
				g.writeLine(fmt.Sprintf("if !v.%s[i].Equals(other.%s[i]) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			}
		}
	}

	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeOptionFieldEquals(fieldName string, refName string) {
	g.writeLine(fmt.Sprintf("if !v.%s.Equals(other.%s) {", fieldName, fieldName))
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeInlineListFieldEquals(fieldName string, schema *Schema) {
	g.writeLine(fmt.Sprintf("if len(v.%s) != len(other.%s) {", fieldName, fieldName))
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("for i := range v.%s {", fieldName))
	g.indentInc()

	if len(schema.Items) > 0 && schema.Items.Single() != nil {
		itemSchema := schema.Items.Single()
		switch {
		case itemSchema.IsRef():
			refName := itemSchema.RefName()
			switch refName {
			case "Int":
				g.writeLine(fmt.Sprintf("if v.%s[i] == nil && other.%s[i] == nil {", fieldName, fieldName))
				g.writeLine(fmt.Sprintf("} else if v.%s[i] == nil || other.%s[i] == nil || v.%s[i].Cmp(other.%s[i]) != 0 {", fieldName, fieldName, fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			case "ByteArray":
				g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s[i], other.%s[i]) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			default:
				g.writeLine(fmt.Sprintf("if !v.%s[i].Equals(other.%s[i]) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			}
		case itemSchema.IsInteger():
			g.writeLine(fmt.Sprintf("if v.%s[i] == nil && other.%s[i] == nil {", fieldName, fieldName))
			g.writeLine(fmt.Sprintf("} else if v.%s[i] == nil || other.%s[i] == nil || v.%s[i].Cmp(other.%s[i]) != 0 {", fieldName, fieldName, fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		case itemSchema.IsBytes():
			g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s[i], other.%s[i]) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		default:
			g.writeLine(fmt.Sprintf("if !v.%s[i].Equals(other.%s[i]) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		}
	} else {
		g.writeLine(fmt.Sprintf("if !v.%s[i].Equals(other.%s[i]) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	}

	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeInlineOptionFieldEquals(fieldName string, schema *Schema) {
	g.writeLine(fmt.Sprintf("if v.%s.IsSet != other.%s.IsSet {", fieldName, fieldName))
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("if v.%s.IsSet {", fieldName))
	g.indentInc()

	inner := schema.OptionInnerType()
	if inner != nil {
		switch {
		case inner.IsRef():
			refName := inner.RefName()
			switch refName {
			case "Int":
				g.writeLine(fmt.Sprintf("if v.%s.Value == nil && other.%s.Value == nil {", fieldName, fieldName))
				g.writeLine(fmt.Sprintf("} else if v.%s.Value == nil || other.%s.Value == nil || v.%s.Value.Cmp(other.%s.Value) != 0 {", fieldName, fieldName, fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			case "ByteArray":
				g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s.Value, other.%s.Value) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			default:
				if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					typeName := g.normalizeTypeName(refName)
					g.writeLine(fmt.Sprintf("if !%sEquals(v.%s.Value, other.%s.Value) {", typeName, fieldName, fieldName))
					g.indentInc()
					g.writeLine("return false")
					g.indentDec()
					g.writeLine("}")
				} else {
					g.writeLine(fmt.Sprintf("if !v.%s.Value.Equals(other.%s.Value) {", fieldName, fieldName))
					g.indentInc()
					g.writeLine("return false")
					g.indentDec()
					g.writeLine("}")
				}
			}
		case inner.IsInteger():
			g.writeLine(fmt.Sprintf("if v.%s.Value == nil && other.%s.Value == nil {", fieldName, fieldName))
			g.writeLine(fmt.Sprintf("} else if v.%s.Value == nil || other.%s.Value == nil || v.%s.Value.Cmp(other.%s.Value) != 0 {", fieldName, fieldName, fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		case inner.IsBytes():
			g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s.Value, other.%s.Value) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		default:
			g.writeLine(fmt.Sprintf("if !v.%s.Value.Equals(other.%s.Value) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		}
	} else {
		g.writeLine(fmt.Sprintf("if !v.%s.Value.Equals(other.%s.Value) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	}

	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeStructToPlutusData(name string, schema *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()

	if len(schema.Fields) == 0 {
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d), nil", constrIndex))
	} else {
		g.writeLine(fmt.Sprintf("fields := make([]PlutusData, %d)", len(schema.Fields)))
		for i, field := range schema.Fields {
			fieldName := g.normalizeFieldName(field.Title, i)
			g.writeFieldToPlutusData(fieldName, &field, i)
		}
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, fields...), nil", constrIndex))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeFieldToPlutusData(fieldName string, schema *Schema, index int) {
	switch {
	case schema.IsRef():
		refName := schema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("fields[%d] = NewIntPlutusData(v.%s)", index, fieldName))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("fields[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
		case "Bool":
			g.writeLine(fmt.Sprintf("if v.%s {", fieldName))
			g.indentInc()
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index))
			g.indentDec()
			g.writeLine("} else {")
			g.indentInc()
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0)", index))
			g.indentDec()
			g.writeLine("}")
		case "Data":
			// Data type is raw PlutusData
			g.writeLine(fmt.Sprintf("fields[%d] = v.%s", index, fieldName))
		default:
			if strings.HasPrefix(refName, "List$") {
				// List type - handle inline
				g.writeListFieldToPlutusData(fieldName, refName, index)
			} else if strings.HasPrefix(refName, "Pairs$") {
				// Map type - serialize as PlutusData map
				g.writeMapFieldToPlutusData(fieldName, refName, index)
			} else if strings.HasPrefix(refName, "Option$") {
				// Option type - handle as pointer
				g.writeOptionRefToPlutusData(fieldName, refName, index)
			} else if g.isPrimitiveWrapper(refName, "bytes") {
				// Primitive wrapper for bytes
				g.writeLine(fmt.Sprintf("fields[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				// Primitive wrapper for integer
				g.writeLine(fmt.Sprintf("fields[%d] = NewIntPlutusData(v.%s)", index, fieldName))
			} else {
				// Custom type with ToPlutusData
				// Check if it's an enum type (interface) that could be nil
				if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					g.writeLine(fmt.Sprintf("if v.%s == nil {", fieldName))
					g.indentInc()
					g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: value is nil (expected %s)")`, fieldName, g.normalizeTypeName(refName)))
					g.indentDec()
					g.writeLine("}")
				}
				g.writeLine(fmt.Sprintf("field%d, err := v.%s.ToPlutusData()", index, fieldName))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: %%w", err)`, fieldName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("fields[%d] = field%d", index, index))
			}
		}
	case schema.IsInteger():
		g.writeLine(fmt.Sprintf("fields[%d] = NewIntPlutusData(v.%s)", index, fieldName))
	case schema.IsBytes():
		g.writeLine(fmt.Sprintf("fields[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
	case schema.IsList():
		g.writeLine(fmt.Sprintf("list%d := make([]PlutusData, len(v.%s))", index, fieldName))
		g.writeLine(fmt.Sprintf("for i, item := range v.%s {", fieldName))
		g.indentInc()
		if len(schema.Items) > 0 && schema.Items.Single() != nil {
			itemSchema := schema.Items.Single()
			g.writeListItemToPlutusData(itemSchema, index)
		} else {
			g.writeLine("itemPd, err := item.ToPlutusData()")
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s[%%d]: %%w", i, err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("list%d[i] = itemPd", index))
		}
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("fields[%d] = NewListPlutusData(list%d...)", index, index))
	case schema.IsMap():
		// Map type - serialize inline
		g.writeInlineMapFieldToPlutusData(fieldName, schema, index)
	case schema.IsBoolean():
		g.writeLine(fmt.Sprintf("if v.%s {", fieldName))
		g.indentInc()
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index))
		g.indentDec()
		g.writeLine("} else {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0)", index))
		g.indentDec()
		g.writeLine("}")
	case schema.IsOption():
		inner := schema.OptionInnerType()
		g.writeLine(fmt.Sprintf("if v.%s.IsSet {", fieldName))
		g.indentInc()
		if inner != nil && (inner.IsRef() || inner.IsInteger() || inner.IsBytes()) {
			// Simple inner type
			g.writeOptionSomeValue(fieldName, inner, index)
		} else {
			// Check if inner type is an enum (interface) that could be nil
			if inner != nil && inner.IsRef() {
				refName := inner.RefName()
				if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					g.writeLine(fmt.Sprintf("if v.%s.Value == nil {", fieldName))
					g.indentInc()
					g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s.Value: value is nil (expected %s)")`, fieldName, g.normalizeTypeName(refName)))
					g.indentDec()
					g.writeLine("}")
				}
			}
			g.writeLine(fmt.Sprintf("innerPd, err := v.%s.Value.ToPlutusData()", fieldName))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s.Value: %%w", err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, innerPd)", index))
		}
		g.indentDec()
		g.writeLine("} else {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index)) // None
		g.indentDec()
		g.writeLine("}")
	default:
		// Custom type
		g.writeLine(fmt.Sprintf("field%d, err := v.%s.ToPlutusData()", index, fieldName))
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: %%w", err)`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("fields[%d] = field%d", index, index))
	}
}

func (g *Generator) writeListFieldToPlutusData(fieldName, refName string, index int) {
	// Extract inner type from List$Type
	inner := strings.TrimPrefix(refName, "List$")
	inner = strings.ReplaceAll(inner, "~1", "/")

	g.writeLine(fmt.Sprintf("list%d := make([]PlutusData, len(v.%s))", index, fieldName))
	g.writeLine(fmt.Sprintf("for i, item := range v.%s {", fieldName))
	g.indentInc()

	switch inner {
	case "Int":
		g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", index))
	case "ByteArray":
		g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", index))
	case "Bool":
		g.writeLine("if item {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(1)", index))
		g.indentDec()
		g.writeLine("} else {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(0)", index))
		g.indentDec()
		g.writeLine("}")
	default:
		if g.isPrimitiveWrapper(inner, "bytes") {
			g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", index))
		} else if g.isPrimitiveWrapper(inner, "integer") {
			g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", index))
		} else {
			g.writeLine("itemPd, err := item.ToPlutusData()")
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s[%%d]: %%w", i, err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("list%d[i] = itemPd", index))
		}
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("fields[%d] = NewListPlutusData(list%d...)", index, index))
}

func (g *Generator) writeMapFieldToPlutusData(fieldName string, refName string, index int) {
	// Parse Pairs$keyType_valueType
	inner := strings.TrimPrefix(refName, "Pairs$")
	inner = strings.ReplaceAll(inner, "~1", "/")
	parts := strings.SplitN(inner, "_", 2)

	var keyType, valueType string
	if len(parts) == 2 {
		keyType = parts[0]
		valueType = parts[1]
	} else {
		keyType = "ByteArray"
		valueType = "ByteArray"
	}

	g.writeLine(fmt.Sprintf("mapEntries%d := make([]PlutusDataMapEntry, 0, len(v.%s))", index, fieldName))
	g.writeLine(fmt.Sprintf("for k, val := range v.%s {", fieldName))
	g.indentInc()

	// Generate key serialization
	g.writeMapKeyToPlutusData(keyType, index)

	// Generate value serialization
	g.writeMapValueToPlutusData(valueType, fieldName, index)

	g.writeLine(fmt.Sprintf("mapEntries%d = append(mapEntries%d, PlutusDataMapEntry{Key: keyPd%d, Value: valPd%d})", index, index, index, index))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("fields[%d] = NewMapPlutusData(mapEntries%d...)", index, index))
}

func (g *Generator) writeMapKeyToPlutusData(keyType string, index int) {
	switch keyType {
	case "Int":
		g.writeLine(fmt.Sprintf("keyPd%d := NewIntPlutusData(k)", index))
	case "ByteArray":
		// If keyType is []byte, but Go map keys can't be []byte, so it's likely string
		g.writeLine(fmt.Sprintf("keyPd%d := NewBytesPlutusData([]byte(k))", index))
	default:
		if g.isPrimitiveWrapper(keyType, "bytes") {
			g.writeLine(fmt.Sprintf("keyPd%d := NewBytesPlutusData([]byte(k))", index))
		} else if g.isPrimitiveWrapper(keyType, "integer") {
			g.writeLine(fmt.Sprintf("keyPd%d := NewIntPlutusData(k)", index))
		} else {
			// Complex key type
			g.writeLine(fmt.Sprintf("keyPd%d, err := k.ToPlutusData()", index))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("map key: %%w", err)`))
			g.indentDec()
			g.writeLine("}")
		}
	}
}

func (g *Generator) writeMapValueToPlutusData(valueType string, fieldName string, index int) {
	switch valueType {
	case "Int":
		g.writeLine(fmt.Sprintf("valPd%d := NewIntPlutusData(val)", index))
	case "ByteArray":
		g.writeLine(fmt.Sprintf("valPd%d := NewBytesPlutusData(val)", index))
	default:
		if g.isPrimitiveWrapper(valueType, "bytes") {
			g.writeLine(fmt.Sprintf("valPd%d := NewBytesPlutusData(val)", index))
		} else if g.isPrimitiveWrapper(valueType, "integer") {
			g.writeLine(fmt.Sprintf("valPd%d := NewIntPlutusData(val)", index))
		} else if strings.HasPrefix(valueType, "Pairs$") {
			// Nested map - parse inner types and serialize
			innerDef := strings.TrimPrefix(valueType, "Pairs$")
			innerDef = strings.ReplaceAll(innerDef, "~1", "/")
			innerParts := strings.SplitN(innerDef, "_", 2)
			innerKeyType := "ByteArray"
			innerValueType := "ByteArray"
			if len(innerParts) == 2 {
				innerKeyType = innerParts[0]
				innerValueType = innerParts[1]
			}
			g.writeLine(fmt.Sprintf("innerEntries%d := make([]PlutusDataMapEntry, 0, len(val))", index))
			g.writeLine("for ik, iv := range val {")
			g.indentInc()
			// Serialize inner key
			switch innerKeyType {
			case "Int":
				g.writeLine(fmt.Sprintf("ikPd%d := NewIntPlutusData(ik)", index))
			case "ByteArray":
				g.writeLine(fmt.Sprintf("ikPd%d := NewBytesPlutusData([]byte(ik))", index))
			default:
				if g.isPrimitiveWrapper(innerKeyType, "bytes") {
					g.writeLine(fmt.Sprintf("ikPd%d := NewBytesPlutusData([]byte(ik))", index))
				} else if g.isPrimitiveWrapper(innerKeyType, "integer") {
					g.writeLine(fmt.Sprintf("ikPd%d := NewIntPlutusData(ik)", index))
				} else {
					g.writeLine(fmt.Sprintf("ikPd%d := NewBytesPlutusData([]byte(ik))", index))
				}
			}
			// Serialize inner value
			switch innerValueType {
			case "Int":
				g.writeLine(fmt.Sprintf("ivPd%d := NewIntPlutusData(iv)", index))
			case "ByteArray":
				g.writeLine(fmt.Sprintf("ivPd%d := NewBytesPlutusData(iv)", index))
			default:
				if g.isPrimitiveWrapper(innerValueType, "bytes") {
					g.writeLine(fmt.Sprintf("ivPd%d := NewBytesPlutusData(iv)", index))
				} else if g.isPrimitiveWrapper(innerValueType, "integer") {
					g.writeLine(fmt.Sprintf("ivPd%d := NewIntPlutusData(iv)", index))
				} else {
					g.writeLine(fmt.Sprintf("ivPd%d, err := iv.ToPlutusData()", index))
					g.writeLine("if err != nil {")
					g.indentInc()
					g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: nested map value: %%w", err)`, fieldName))
					g.indentDec()
					g.writeLine("}")
				}
			}
			g.writeLine(fmt.Sprintf("innerEntries%d = append(innerEntries%d, PlutusDataMapEntry{Key: ikPd%d, Value: ivPd%d})", index, index, index, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("valPd%d := NewMapPlutusData(innerEntries%d...)", index, index))
		} else {
			// Complex value type
			g.writeLine(fmt.Sprintf("valPd%d, err := val.ToPlutusData()", index))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: map value: %%w", err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
		}
	}
}

func (g *Generator) writeInlineMapFieldToPlutusData(fieldName string, schema *Schema, index int) {
	// For inline map schemas
	keySchema := schema.Keys
	valueSchema := schema.Values

	g.writeLine(fmt.Sprintf("mapEntries%d := make([]PlutusDataMapEntry, 0, len(v.%s))", index, fieldName))
	g.writeLine(fmt.Sprintf("for k, val := range v.%s {", fieldName))
	g.indentInc()

	// Generate key serialization based on schema
	g.writeInlineMapKeyToPlutusData(keySchema, index)

	// Generate value serialization based on schema
	g.writeInlineMapValueToPlutusData(valueSchema, fieldName, index)

	g.writeLine(fmt.Sprintf("mapEntries%d = append(mapEntries%d, PlutusDataMapEntry{Key: keyPd%d, Value: valPd%d})", index, index, index, index))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("fields[%d] = NewMapPlutusData(mapEntries%d...)", index, index))
}

func (g *Generator) writeInlineMapKeyToPlutusData(keySchema *Schema, index int) {
	if keySchema == nil {
		g.writeLine(fmt.Sprintf("keyPd%d := NewBytesPlutusData([]byte(k))", index))
		return
	}

	switch {
	case keySchema.IsRef():
		refName := keySchema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("keyPd%d := NewIntPlutusData(k)", index))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("keyPd%d := NewBytesPlutusData([]byte(k))", index))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("keyPd%d := NewBytesPlutusData([]byte(k))", index))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("keyPd%d := NewIntPlutusData(k)", index))
			} else {
				g.writeLine(fmt.Sprintf("keyPd%d, err := k.ToPlutusData()", index))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(`return PlutusData{}, fmt.Errorf("map key: %w", err)`)
				g.indentDec()
				g.writeLine("}")
			}
		}
	case keySchema.IsInteger():
		g.writeLine(fmt.Sprintf("keyPd%d := NewIntPlutusData(k)", index))
	case keySchema.IsBytes():
		g.writeLine(fmt.Sprintf("keyPd%d := NewBytesPlutusData([]byte(k))", index))
	default:
		g.writeLine(fmt.Sprintf("keyPd%d := NewBytesPlutusData([]byte(k))", index))
	}
}

func (g *Generator) writeInlineMapValueToPlutusData(valueSchema *Schema, fieldName string, index int) {
	if valueSchema == nil {
		g.writeLine(fmt.Sprintf("valPd%d := NewBytesPlutusData(val)", index))
		return
	}

	switch {
	case valueSchema.IsRef():
		refName := valueSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("valPd%d := NewIntPlutusData(val)", index))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("valPd%d := NewBytesPlutusData(val)", index))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("valPd%d := NewBytesPlutusData(val)", index))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("valPd%d := NewIntPlutusData(val)", index))
			} else {
				g.writeLine(fmt.Sprintf("valPd%d, err := val.ToPlutusData()", index))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: map value: %%w", err)`, fieldName))
				g.indentDec()
				g.writeLine("}")
			}
		}
	case valueSchema.IsInteger():
		g.writeLine(fmt.Sprintf("valPd%d := NewIntPlutusData(val)", index))
	case valueSchema.IsBytes():
		g.writeLine(fmt.Sprintf("valPd%d := NewBytesPlutusData(val)", index))
	case valueSchema.IsMap():
		// Nested map - serialize inline
		innerKeySchema := valueSchema.Keys
		innerValueSchema := valueSchema.Values
		g.writeLine(fmt.Sprintf("innerEntries%d := make([]PlutusDataMapEntry, 0, len(val))", index))
		g.writeLine("for ik, iv := range val {")
		g.indentInc()
		// Serialize inner key
		if innerKeySchema != nil && innerKeySchema.IsInteger() {
			g.writeLine(fmt.Sprintf("ikPd%d := NewIntPlutusData(ik)", index))
		} else {
			g.writeLine(fmt.Sprintf("ikPd%d := NewBytesPlutusData([]byte(ik))", index))
		}
		// Serialize inner value
		if innerValueSchema != nil && innerValueSchema.IsInteger() {
			g.writeLine(fmt.Sprintf("ivPd%d := NewIntPlutusData(iv)", index))
		} else if innerValueSchema != nil && innerValueSchema.IsBytes() {
			g.writeLine(fmt.Sprintf("ivPd%d := NewBytesPlutusData(iv)", index))
		} else {
			g.writeLine(fmt.Sprintf("ivPd%d, err := iv.ToPlutusData()", index))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: nested map value: %%w", err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
		}
		g.writeLine(fmt.Sprintf("innerEntries%d = append(innerEntries%d, PlutusDataMapEntry{Key: ikPd%d, Value: ivPd%d})", index, index, index, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("valPd%d := NewMapPlutusData(innerEntries%d...)", index, index))
	default:
		g.writeLine(fmt.Sprintf("valPd%d, err := val.ToPlutusData()", index))
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: map value: %%w", err)`, fieldName))
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeListItemToPlutusData(itemSchema *Schema, listIndex int) {
	switch {
	case itemSchema.IsRef():
		refName := itemSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", listIndex))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", listIndex))
		case "Bool":
			g.writeLine("if item {")
			g.indentInc()
			g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(1)", listIndex))
			g.indentDec()
			g.writeLine("} else {")
			g.indentInc()
			g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(0)", listIndex))
			g.indentDec()
			g.writeLine("}")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", listIndex))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", listIndex))
			} else {
				g.writeLine("itemPd, err := item.ToPlutusData()")
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(`return PlutusData{}, fmt.Errorf("list item[%d]: %w", i, err)`)
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("list%d[i] = itemPd", listIndex))
			}
		}
	case itemSchema.IsInteger():
		g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", listIndex))
	case itemSchema.IsBytes():
		g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", listIndex))
	default:
		g.writeLine("itemPd, err := item.ToPlutusData()")
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine(`return PlutusData{}, fmt.Errorf("list item[%d]: %w", i, err)`)
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("list%d[i] = itemPd", listIndex))
	}
}

func (g *Generator) writeOptionSomeValue(fieldName string, inner *Schema, index int) {
	switch {
	case inner.IsRef():
		refName := inner.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s.Value))", index, fieldName))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(v.%s.Value))", index, fieldName))
		default:
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(v.%s.Value))", index, fieldName))
		}
	case inner.IsInteger():
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s.Value))", index, fieldName))
	case inner.IsBytes():
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(v.%s.Value))", index, fieldName))
	}
}

func (g *Generator) writeOptionRefToPlutusData(fieldName string, refName string, index int) {
	// Extract inner type from Option$InnerType
	innerRef := strings.TrimPrefix(refName, "Option$")
	innerRef = strings.ReplaceAll(innerRef, "~1", "/")

	g.writeLine(fmt.Sprintf("if v.%s.IsSet {", fieldName))
	g.indentInc()

	switch innerRef {
	case "Int":
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s.Value))", index, fieldName))
	case "ByteArray":
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(v.%s.Value))", index, fieldName))
	default:
		if g.isPrimitiveWrapper(innerRef, "bytes") {
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(v.%s.Value))", index, fieldName))
		} else if g.isPrimitiveWrapper(innerRef, "integer") {
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s.Value))", index, fieldName))
		} else {
			// Complex inner type - call ToPlutusData
			// Check if it's an enum (interface) that could be nil
			if defSchema, ok := g.bp.Definitions[g.unescapeRef(innerRef)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
				g.writeLine(fmt.Sprintf("if v.%s.Value == nil {", fieldName))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s.Value: value is nil (expected %s)")`, fieldName, g.normalizeTypeName(innerRef)))
				g.indentDec()
				g.writeLine("}")
			}
			g.writeLine(fmt.Sprintf("innerPd, err := v.%s.Value.ToPlutusData()", fieldName))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s.Value: %%w", err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, innerPd)", index))
		}
	}

	g.indentDec()
	g.writeLine("} else {")
	g.indentInc()
	g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index)) // None
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeOptionRefFromPlutusData(fieldName string, refName string, index int) {
	// Extract inner type from Option$InnerType
	innerRef := strings.TrimPrefix(refName, "Option$")
	innerRef = strings.ReplaceAll(innerRef, "~1", "/")
	goType := g.refToGoType(innerRef)

	// Check if it's a constructor (Option is encoded as constructor 0 for Some, 1 for None)
	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected Option constructor, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
	g.indentDec()
	g.writeLine("}")

	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Index == 1 {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf("v.%s.IsSet = false // None", fieldName))
	g.indentDec()
	g.writeLine(fmt.Sprintf("} else if pd.Constr.Fields[%d].Constr.Index == 0 {", index))
	g.indentInc()

	// Check that Some has exactly 1 field
	g.writeLine(fmt.Sprintf("if len(pd.Constr.Fields[%d].Constr.Fields) != 1 {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: Option Some should have 1 field, got %%d", len(pd.Constr.Fields[%d].Constr.Fields))`, fieldName, index))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("v.%s.IsSet = true", fieldName))

	// Extract the inner value based on type
	switch innerRef {
	case "Int":
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].Integer == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s.Value = pd.Constr.Fields[%d].Constr.Fields[0].Integer", fieldName, index))
	case "ByteArray":
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].ByteString == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s.Value = pd.Constr.Fields[%d].Constr.Fields[0].ByteString", fieldName, index))
	default:
		if g.isPrimitiveWrapper(innerRef, "bytes") {
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].ByteString == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s.Value = pd.Constr.Fields[%d].Constr.Fields[0].ByteString", fieldName, index))
		} else if g.isPrimitiveWrapper(innerRef, "integer") {
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].Integer == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s.Value = pd.Constr.Fields[%d].Constr.Fields[0].Integer", fieldName, index))
		} else {
			// Check if it's an enum type (interface)
			unescaped := g.unescapeRef(innerRef)
			if def, ok := g.bp.Definitions[unescaped]; ok && def.IsEnum() && !def.IsSingleConstructor() {
				// Enum type - use factory function
				typeName := g.normalizeTypeName(innerRef)
				g.writeLine(fmt.Sprintf("%sVal, err := %sFromPlutusData(pd.Constr.Fields[%d].Constr.Fields[0])", fieldName, typeName, index))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s.Value = %sVal", fieldName, fieldName))
			} else {
				// Complex inner type - call FromPlutusData on the Value
				g.writeLine(fmt.Sprintf("v.%s.Value = %s{}", fieldName, goType))
				g.writeLine(fmt.Sprintf("if err := v.%s.Value.FromPlutusData(pd.Constr.Fields[%d].Constr.Fields[0]); err != nil {", fieldName, index))
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
			}
		}
	}

	g.indentDec()
	g.writeLine("} else {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: unknown Option constructor index %%d", pd.Constr.Fields[%d].Constr.Index)`, fieldName, index))
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeStructFromPlutusData(name string, schema *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()

	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")

	g.writeLine(fmt.Sprintf("if pd.Constr.Index != %d {", constrIndex))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong constructor index for %s: expected %d, got %%d", pd.Constr.Index)`, name, constrIndex))
	g.indentDec()
	g.writeLine("}")

	if len(schema.Fields) > 0 {
		g.writeLine(fmt.Sprintf("if len(pd.Constr.Fields) != %d {", len(schema.Fields)))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong number of fields for %s: expected %d, got %%d", len(pd.Constr.Fields))`, name, len(schema.Fields)))
		g.indentDec()
		g.writeLine("}")

		for i, field := range schema.Fields {
			fieldName := g.normalizeFieldName(field.Title, i)
			g.writeFieldFromPlutusData(fieldName, &field, i)
		}
	}

	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeFieldFromPlutusData(fieldName string, schema *Schema, index int) {
	switch {
	case schema.IsRef():
		refName := schema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Integer == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Integer", fieldName, index))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].ByteString == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].ByteString", fieldName, index))
		case "Bool":
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected constructor for bool, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Constr.Index == 1", fieldName, index))
		case "Data":
			// Data type is raw PlutusData - store directly
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d]", fieldName, index))
		default:
			if strings.HasPrefix(refName, "List$") {
				// List type - handle inline
				g.writeListFieldFromPlutusData(fieldName, refName, index)
			} else if strings.HasPrefix(refName, "Pairs$") {
				// Map type - deserialize from PlutusData map
				g.writeMapFieldFromPlutusData(fieldName, refName, index)
			} else if strings.HasPrefix(refName, "Option$") {
				// Option type - handle as pointer
				g.writeOptionRefFromPlutusData(fieldName, refName, index)
			} else if g.isPrimitiveWrapper(refName, "bytes") {
				// Primitive wrapper for bytes
				g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].ByteString == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].ByteString", fieldName, index))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				// Primitive wrapper for integer
				g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Integer == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Integer", fieldName, index))
			} else {
				// Check if it's an enum type
				if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					typeName := g.normalizeTypeName(refName)
					g.writeLine(fmt.Sprintf("%sVal, err := %sFromPlutusData(pd.Constr.Fields[%d])", fieldName, typeName, index))
					g.writeLine("if err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine(fmt.Sprintf("v.%s = %sVal", fieldName, fieldName))
				} else {
					g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.Constr.Fields[%d]); err != nil {", fieldName, index))
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
				}
			}
		}
	case schema.IsInteger():
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Integer == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Integer", fieldName, index))
	case schema.IsBytes():
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].ByteString == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].ByteString", fieldName, index))
	case schema.IsList():
		g.writeListFieldFromPlutusDataInline(fieldName, schema, index)
	case schema.IsMap():
		g.writeInlineMapFieldFromPlutusData(fieldName, schema, index)
	case schema.IsBoolean():
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected constructor for bool, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Constr.Index == 1", fieldName, index))
	default:
		// Check if it might be an enum
		g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.Constr.Fields[%d]); err != nil {", fieldName, index))
		g.indentInc()
		g.writeLine("return err")
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeListFieldFromPlutusData(fieldName, refName string, index int) {
	// Extract inner type from List$Type
	inner := strings.TrimPrefix(refName, "List$")
	inner = strings.ReplaceAll(inner, "~1", "/")

	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].List == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("field %s: expected list")`, fieldName))
	g.indentDec()
	g.writeLine("}")

	goType := g.refToGoType(inner)
	g.writeLine(fmt.Sprintf("v.%s = make([]%s, len(pd.Constr.Fields[%d].List))", fieldName, goType, index))
	g.writeLine(fmt.Sprintf("for i, item := range pd.Constr.Fields[%d].List {", index))
	g.indentInc()

	switch inner {
	case "Int":
		g.writeLine("if item.Integer == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected integer, got %%s", plutusDataTypeString(item))`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
	case "ByteArray":
		g.writeLine("if item.ByteString == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected bytes, got %%s", plutusDataTypeString(item))`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
	case "Bool":
		g.writeLine("if item.Constr == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected bool constructor, got %%s", plutusDataTypeString(item))`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s[i] = item.Constr.Index == 1", fieldName))
	default:
		if g.isPrimitiveWrapper(inner, "bytes") {
			g.writeLine("if item.ByteString == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected bytes, got %%s", plutusDataTypeString(item))`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
		} else if g.isPrimitiveWrapper(inner, "integer") {
			g.writeLine("if item.Integer == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected integer, got %%s", plutusDataTypeString(item))`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
		} else if defSchema, ok := g.bp.Definitions[inner]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
			// Check if it's an enum (multi-constructor, not single-constructor)
			typeName := g.normalizeTypeName(inner)
			g.writeLine(fmt.Sprintf("itemVal, err := %sFromPlutusData(item)", typeName))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine("return err")
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s[i] = itemVal", fieldName))
		} else {
			g.writeLine(fmt.Sprintf("if err := v.%s[i].FromPlutusData(item); err != nil {", fieldName))
			g.indentInc()
			g.writeLine("return err")
			g.indentDec()
			g.writeLine("}")
		}
	}

	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeListFieldFromPlutusDataInline(fieldName string, schema *Schema, index int) {
	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].List == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("field %s: expected list")`, fieldName))
	g.indentDec()
	g.writeLine("}")

	if len(schema.Items) > 0 && schema.Items.Single() != nil {
		itemSchema := schema.Items.Single()
		goType := g.schemaToGoType(itemSchema)
		g.writeLine(fmt.Sprintf("v.%s = make([]%s, len(pd.Constr.Fields[%d].List))", fieldName, goType, index))
		g.writeLine(fmt.Sprintf("for i, item := range pd.Constr.Fields[%d].List {", index))
		g.indentInc()

		switch {
		case itemSchema.IsRef():
			refName := itemSchema.RefName()
			switch refName {
			case "Int":
				g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
			case "ByteArray":
				g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
			case "Bool":
				g.writeLine(fmt.Sprintf("v.%s[i] = item.Constr != nil && item.Constr.Index == 1", fieldName))
			default:
				if g.isPrimitiveWrapper(refName, "bytes") {
					g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
				} else if g.isPrimitiveWrapper(refName, "integer") {
					g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
				} else if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					typeName := g.normalizeTypeName(refName)
					g.writeLine(fmt.Sprintf("itemVal, err := %sFromPlutusData(item)", typeName))
					g.writeLine("if err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine(fmt.Sprintf("v.%s[i] = itemVal", fieldName))
				} else {
					g.writeLine(fmt.Sprintf("if err := v.%s[i].FromPlutusData(item); err != nil {", fieldName))
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
				}
			}
		case itemSchema.IsInteger():
			g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
		case itemSchema.IsBytes():
			g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
		default:
			g.writeLine(fmt.Sprintf("if err := v.%s[i].FromPlutusData(item); err != nil {", fieldName))
			g.indentInc()
			g.writeLine("return err")
			g.indentDec()
			g.writeLine("}")
		}

		g.indentDec()
		g.writeLine("}")
	} else {
		g.writeLine(fmt.Sprintf("// TODO: List deserialization for %s", fieldName))
	}
}

func (g *Generator) writeMapFieldFromPlutusData(fieldName string, refName string, index int) {
	// Parse Pairs$keyType_valueType
	inner := strings.TrimPrefix(refName, "Pairs$")
	inner = strings.ReplaceAll(inner, "~1", "/")
	parts := strings.SplitN(inner, "_", 2)

	var keyType, valueType string
	if len(parts) == 2 {
		keyType = parts[0]
		valueType = parts[1]
	} else {
		keyType = "ByteArray"
		valueType = "ByteArray"
	}

	goKeyType := g.refToGoType(keyType)
	// []byte can't be a map key in Go, use string
	if goKeyType == "[]byte" {
		goKeyType = "string"
	}
	goValueType := g.refToGoType(valueType)

	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Map == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected map, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("v.%s = make(map[%s]%s)", fieldName, goKeyType, goValueType))
	g.writeLine(fmt.Sprintf("for _, entry := range pd.Constr.Fields[%d].Map {", index))
	g.indentInc()

	// Generate key deserialization
	g.writeMapKeyFromPlutusData(keyType, fieldName)

	// Generate value deserialization
	g.writeMapValueFromPlutusData(valueType, fieldName)

	g.writeLine("v." + fieldName + "[mapKey] = mapVal")
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeMapKeyFromPlutusData(keyType string, fieldName string) {
	switch keyType {
	case "Int":
		g.writeLine("mapKey := entry.Key.Integer")
	case "ByteArray":
		// Go map keys can't be []byte, so convert to string
		g.writeLine("mapKey := string(entry.Key.ByteString)")
	default:
		if g.isPrimitiveWrapper(keyType, "bytes") {
			g.writeLine("mapKey := string(entry.Key.ByteString)")
		} else if g.isPrimitiveWrapper(keyType, "integer") {
			g.writeLine("mapKey := entry.Key.Integer")
		} else {
			// Complex key type
			goKeyType := g.refToGoType(keyType)
			g.writeLine(fmt.Sprintf("var mapKey %s", goKeyType))
			g.writeLine("if err := mapKey.FromPlutusData(entry.Key); err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: map key: %%w", err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
		}
	}
}

func (g *Generator) writeMapValueFromPlutusData(valueType string, fieldName string) {
	switch valueType {
	case "Int":
		g.writeLine("mapVal := entry.Value.Integer")
	case "ByteArray":
		g.writeLine("mapVal := entry.Value.ByteString")
	default:
		if g.isPrimitiveWrapper(valueType, "bytes") {
			g.writeLine("mapVal := entry.Value.ByteString")
		} else if g.isPrimitiveWrapper(valueType, "integer") {
			g.writeLine("mapVal := entry.Value.Integer")
		} else if strings.HasPrefix(valueType, "Pairs$") {
			// Nested map - needs type-specific handling
			goValueType := g.pairsToGoType(valueType)
			g.writeLine(fmt.Sprintf("var mapVal %s", goValueType))
			g.writeLine("// Nested map deserialization")
			g.writeLine("if entry.Value.Map != nil {")
			g.indentInc()
			g.writeLine("mapVal = make(" + goValueType + ")")
			g.writeLine("// TODO: deserialize nested map entries")
			g.indentDec()
			g.writeLine("}")
		} else {
			// Complex value type
			goValueType := g.refToGoType(valueType)
			g.writeLine(fmt.Sprintf("var mapVal %s", goValueType))
			g.writeLine("if err := mapVal.FromPlutusData(entry.Value); err != nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: map value: %%w", err)`, fieldName))
			g.indentDec()
			g.writeLine("}")
		}
	}
}

func (g *Generator) writeInlineMapFieldFromPlutusData(fieldName string, schema *Schema, index int) {
	// For inline map schemas
	keySchema := schema.Keys
	valueSchema := schema.Values

	goKeyType := "string"
	if keySchema != nil {
		goKeyType = g.schemaToGoType(keySchema)
		if goKeyType == "[]byte" {
			goKeyType = "string"
		}
	}
	goValueType := "interface{}"
	if valueSchema != nil {
		goValueType = g.schemaToGoType(valueSchema)
	}

	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Map == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected map, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("v.%s = make(map[%s]%s)", fieldName, goKeyType, goValueType))
	g.writeLine(fmt.Sprintf("for _, entry := range pd.Constr.Fields[%d].Map {", index))
	g.indentInc()

	// Generate key deserialization based on schema
	g.writeInlineMapKeyFromPlutusData(keySchema, fieldName)

	// Generate value deserialization based on schema
	g.writeInlineMapValueFromPlutusData(valueSchema, fieldName)

	g.writeLine("v." + fieldName + "[mapKey] = mapVal")
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeInlineMapKeyFromPlutusData(keySchema *Schema, fieldName string) {
	if keySchema == nil {
		g.writeLine("mapKey := string(entry.Key.ByteString)")
		return
	}

	switch {
	case keySchema.IsRef():
		refName := keySchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("mapKey := entry.Key.Integer")
		case "ByteArray":
			g.writeLine("mapKey := string(entry.Key.ByteString)")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("mapKey := string(entry.Key.ByteString)")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("mapKey := entry.Key.Integer")
			} else {
				goKeyType := g.refToGoType(refName)
				g.writeLine(fmt.Sprintf("var mapKey %s", goKeyType))
				g.writeLine("if err := mapKey.FromPlutusData(entry.Key); err != nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: map key: %%w", err)`, fieldName))
				g.indentDec()
				g.writeLine("}")
			}
		}
	case keySchema.IsInteger():
		g.writeLine("mapKey := entry.Key.Integer")
	case keySchema.IsBytes():
		g.writeLine("mapKey := string(entry.Key.ByteString)")
	default:
		g.writeLine("mapKey := string(entry.Key.ByteString)")
	}
}

func (g *Generator) writeInlineMapValueFromPlutusData(valueSchema *Schema, fieldName string) {
	if valueSchema == nil {
		g.writeLine("mapVal := entry.Value")
		return
	}

	switch {
	case valueSchema.IsRef():
		refName := valueSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("mapVal := entry.Value.Integer")
		case "ByteArray":
			g.writeLine("mapVal := entry.Value.ByteString")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("mapVal := entry.Value.ByteString")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("mapVal := entry.Value.Integer")
			} else {
				goValueType := g.refToGoType(refName)
				g.writeLine(fmt.Sprintf("var mapVal %s", goValueType))
				g.writeLine("if err := mapVal.FromPlutusData(entry.Value); err != nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: map value: %%w", err)`, fieldName))
				g.indentDec()
				g.writeLine("}")
			}
		}
	case valueSchema.IsInteger():
		g.writeLine("mapVal := entry.Value.Integer")
	case valueSchema.IsBytes():
		g.writeLine("mapVal := entry.Value.ByteString")
	case valueSchema.IsMap():
		// Nested map
		goValueType := g.schemaToGoType(valueSchema)
		g.writeLine(fmt.Sprintf("var mapVal %s", goValueType))
		g.writeLine("// TODO: deserialize nested map")
	default:
		goValueType := g.schemaToGoType(valueSchema)
		g.writeLine(fmt.Sprintf("var mapVal %s", goValueType))
		g.writeLine("if err := mapVal.FromPlutusData(entry.Value); err != nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: map value: %%w", err)`, fieldName))
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeEnumType(name string, schema *Schema) error {
	// Write interface
	methodName := fmt.Sprintf("is%s", name)
	g.writeLine(fmt.Sprintf("// %s is an enum type with multiple constructors.", name))
	g.writeLine(fmt.Sprintf("type %s interface {", name))
	g.indentInc()
	g.writeLine(fmt.Sprintf("%s()", methodName))
	g.writeLine("ToPlutusData() (PlutusData, error)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Write FromPlutusData function for the enum
	g.writeEnumFromPlutusData(name, schema)

	// Write Equals function for the enum
	g.writeEnumEquals(name, schema)

	// Write variant structs
	for i, variant := range schema.AnyOf {
		variantName := name + g.toGoIdentifier(variant.Title)
		constrIndex := i
		if variant.Index != nil {
			constrIndex = *variant.Index
		}

		if len(variant.Fields) == 0 {
			// Empty struct for enum variants without fields
			g.writeLine(fmt.Sprintf("// %s is a variant of %s.", variantName, name))
			g.writeLine(fmt.Sprintf("type %s struct{}", variantName))
			g.writeLine("")
			g.writeLine(fmt.Sprintf("func (%s) %s() {}", variantName, methodName))
			g.writeLine("")

			// ToPlutusData
			g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", variantName))
			g.indentInc()
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d), nil", constrIndex))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("")

			// FromPlutusData
			g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", variantName))
			g.indentInc()
			g.writeLine("if pd.Constr == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, variantName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("if pd.Constr.Index != %d {", constrIndex))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong constructor index for %s: expected %d, got %%d", pd.Constr.Index)`, variantName, constrIndex))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("return nil")
			g.indentDec()
			g.writeLine("}")
			g.writeLine("")

			// Equals - empty struct always equals another of same type
			g.writeLine(fmt.Sprintf("func (v %s) Equals(other %s) bool {", variantName, variantName))
			g.indentInc()
			g.writeLine("return true")
			g.indentDec()
			g.writeLine("}")
			g.writeLine("")

		} else if len(variant.Fields) == 1 && variant.Fields[0].Title == "" {
			// Single unnamed field - wrapper type
			fieldType := g.schemaToGoType(&variant.Fields[0])
			g.writeLine(fmt.Sprintf("// %s is a variant of %s with a single value.", variantName, name))
			g.writeLine(fmt.Sprintf("type %s struct {", variantName))
			g.indentInc()
			g.writeLine(fmt.Sprintf("Value %s", fieldType))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("")
			g.writeLine(fmt.Sprintf("func (%s) %s() {}", variantName, methodName))
			g.writeLine("")

			// Write ToPlutusData/FromPlutusData for wrapper
			g.writeWrapperToPlutusData(variantName, &variant.Fields[0], constrIndex)
			g.writeWrapperFromPlutusData(variantName, &variant.Fields[0], constrIndex)

			// Write Equals for wrapper
			g.writeWrapperEquals(variantName, &variant.Fields[0])
		} else {
			// Struct with named fields
			g.writeLine(fmt.Sprintf("// %s is a variant of %s.", variantName, name))
			if err := g.writeStructType(variantName, &variant, constrIndex); err != nil {
				return err
			}
			g.writeLine(fmt.Sprintf("func (%s) %s() {}", variantName, methodName))
			g.writeLine("")
		}
	}

	return nil
}

func (g *Generator) writeEnumFromPlutusData(name string, schema *Schema) {
	g.writeLine(fmt.Sprintf("// %sFromPlutusData decodes a %s from PlutusData.", name, name))
	g.writeLine(fmt.Sprintf("func %sFromPlutusData(pd PlutusData) (%s, error) {", name, name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return nil, errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
	g.writeLine("switch pd.Constr.Index {")

	for i, variant := range schema.AnyOf {
		constrIndex := i
		if variant.Index != nil {
			constrIndex = *variant.Index
		}
		variantName := name + g.toGoIdentifier(variant.Title)
		g.writeLine(fmt.Sprintf("case %d:", constrIndex))
		g.indentInc()
		g.writeLine(fmt.Sprintf("var v %s", variantName))
		g.writeLine("if err := v.FromPlutusData(pd); err != nil {")
		g.indentInc()
		g.writeLine("return nil, err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("return v, nil")
		g.indentDec()
	}

	g.writeLine("default:")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return nil, fmt.Errorf("unknown constructor index for %s: got %%d", pd.Constr.Index)`, name))
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeEnumEquals(name string, schema *Schema) {
	g.writeLine(fmt.Sprintf("// %sEquals compares two %s values for equality.", name, name))
	g.writeLine(fmt.Sprintf("func %sEquals(a, b %s) bool {", name, name))
	g.indentInc()
	g.writeLine("if a == nil && b == nil {")
	g.indentInc()
	g.writeLine("return true")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if a == nil || b == nil {")
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("// Compare by serializing to PlutusData")
	g.writeLine("aPd, aErr := a.ToPlutusData()")
	g.writeLine("bPd, bErr := b.ToPlutusData()")
	g.writeLine("if aErr != nil || bErr != nil {")
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return aPd.Equals(bPd)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeTupleType(name string, schema *Schema) error {
	g.writeLine(fmt.Sprintf("// %s represents a tuple type.", name))
	g.writeLine(fmt.Sprintf("type %s struct {", name))
	g.indentInc()

	// Generate fields
	for i, item := range schema.Items {
		fieldName := fmt.Sprintf("Field%d", i)
		goType := g.schemaToGoType(item)
		g.writeLine(fmt.Sprintf("%s %s", fieldName, goType))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine(fmt.Sprintf("items := make([]PlutusData, %d)", len(schema.Items)))

	for i, item := range schema.Items {
		fieldName := fmt.Sprintf("Field%d", i)
		g.writeTupleFieldToPlutusData(fieldName, item, i)
	}

	g.writeLine("return NewListPlutusData(items...), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.List == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected list for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("if len(pd.List) != %d {", len(schema.Items)))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong number of items for %s: expected %d, got %%d", len(pd.List))`, name, len(schema.Items)))
	g.indentDec()
	g.writeLine("}")

	for i, item := range schema.Items {
		fieldName := fmt.Sprintf("Field%d", i)
		g.writeTupleFieldFromPlutusData(fieldName, item, i)
	}

	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Equals method
	g.writeTupleEquals(name, schema)

	return nil
}

func (g *Generator) writeTupleEquals(name string, schema *Schema) {
	g.writeLine(fmt.Sprintf("func (v %s) Equals(other %s) bool {", name, name))
	g.indentInc()

	for i, item := range schema.Items {
		fieldName := fmt.Sprintf("Field%d", i)
		g.writeTupleFieldEquals(fieldName, item)
	}

	g.writeLine("return true")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeTupleFieldEquals(fieldName string, item *Schema) {
	switch {
	case item.IsRef():
		refName := item.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("if v.%s == nil && other.%s == nil {", fieldName, fieldName))
			g.writeLine(fmt.Sprintf("} else if v.%s == nil || other.%s == nil || v.%s.Cmp(other.%s) != 0 {", fieldName, fieldName, fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		case "ByteArray":
			g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s, other.%s) {", fieldName, fieldName))
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s, other.%s) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("if v.%s == nil && other.%s == nil {", fieldName, fieldName))
				g.writeLine(fmt.Sprintf("} else if v.%s == nil || other.%s == nil || v.%s.Cmp(other.%s) != 0 {", fieldName, fieldName, fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else {
				g.writeLine(fmt.Sprintf("if !v.%s.Equals(other.%s) {", fieldName, fieldName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			}
		}
	case item.IsInteger():
		g.writeLine(fmt.Sprintf("if v.%s == nil && other.%s == nil {", fieldName, fieldName))
		g.writeLine(fmt.Sprintf("} else if v.%s == nil || other.%s == nil || v.%s.Cmp(other.%s) != 0 {", fieldName, fieldName, fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case item.IsBytes():
		g.writeLine(fmt.Sprintf("if !bytes.Equal(v.%s, other.%s) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	default:
		g.writeLine(fmt.Sprintf("if !v.%s.Equals(other.%s) {", fieldName, fieldName))
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeListTypeAlias(name string, schema *Schema) error {
	// Get the inner type
	innerSchema := schema.Items.Single()
	if innerSchema == nil {
		return fmt.Errorf("list type %s has no inner type", name)
	}

	innerGoType := g.schemaToGoType(innerSchema)

	g.writeLine(fmt.Sprintf("// %s represents a list of %s.", name, innerGoType))
	g.writeLine(fmt.Sprintf("type %s []%s", name, innerGoType))
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine("items := make([]PlutusData, len(v))")
	g.writeLine("for i, item := range v {")
	g.indentInc()
	g.writeListAliasItemToPlutusData(innerSchema)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return NewListPlutusData(items...), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.List == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected list for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("*v = make(%s, len(pd.List))", name))
	g.writeLine("for i, item := range pd.List {")
	g.indentInc()
	g.writeListAliasItemFromPlutusData(innerSchema, name)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Equals method
	g.writeListAliasEquals(name, innerSchema)

	return nil
}

func (g *Generator) writeListAliasEquals(name string, innerSchema *Schema) {
	g.writeLine(fmt.Sprintf("func (v %s) Equals(other %s) bool {", name, name))
	g.indentInc()
	g.writeLine("if len(v) != len(other) {")
	g.indentInc()
	g.writeLine("return false")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("for i := range v {")
	g.indentInc()

	switch {
	case innerSchema.IsRef():
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("if v[i] == nil && other[i] == nil {")
			g.writeLine("} else if v[i] == nil || other[i] == nil || v[i].Cmp(other[i]) != 0 {")
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		case "ByteArray":
			g.writeLine("if !bytes.Equal(v[i], other[i]) {")
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("if !bytes.Equal(v[i], other[i]) {")
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if v[i] == nil && other[i] == nil {")
				g.writeLine("} else if v[i] == nil || other[i] == nil || v[i].Cmp(other[i]) != 0 {")
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
				typeName := g.normalizeTypeName(refName)
				g.writeLine(fmt.Sprintf("if !%sEquals(v[i], other[i]) {", typeName))
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			} else {
				g.writeLine("if !v[i].Equals(other[i]) {")
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
			}
		}
	case innerSchema.IsInteger():
		g.writeLine("if v[i] == nil && other[i] == nil {")
		g.writeLine("} else if v[i] == nil || other[i] == nil || v[i].Cmp(other[i]) != 0 {")
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	case innerSchema.IsBytes():
		g.writeLine("if !bytes.Equal(v[i], other[i]) {")
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	default:
		g.writeLine("if !v[i].Equals(other[i]) {")
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("return true")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeListAliasItemToPlutusData(innerSchema *Schema) {
	switch {
	case innerSchema.IsRef():
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("items[i] = NewIntPlutusData(item)")
		case "ByteArray":
			g.writeLine("items[i] = NewBytesPlutusData(item)")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("items[i] = NewBytesPlutusData(item)")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("items[i] = NewIntPlutusData(item)")
			} else {
				g.writeLine("pd, err := item.ToPlutusData()")
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(`return PlutusData{}, fmt.Errorf("item[%d]: %w", i, err)`)
				g.indentDec()
				g.writeLine("}")
				g.writeLine("items[i] = pd")
			}
		}
	case innerSchema.IsInteger():
		g.writeLine("items[i] = NewIntPlutusData(item)")
	case innerSchema.IsBytes():
		g.writeLine("items[i] = NewBytesPlutusData(item)")
	default:
		g.writeLine("pd, err := item.ToPlutusData()")
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine(`return PlutusData{}, fmt.Errorf("item[%d]: %w", i, err)`)
		g.indentDec()
		g.writeLine("}")
		g.writeLine("items[i] = pd")
	}
}

func (g *Generator) writeListAliasItemFromPlutusData(innerSchema *Schema, listName string) {
	switch {
	case innerSchema.IsRef():
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("if item.Integer == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected integer, got %%s", plutusDataTypeString(item))`, listName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("(*v)[i] = item.Integer")
		case "ByteArray":
			g.writeLine("if item.ByteString == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected bytes, got %%s", plutusDataTypeString(item))`, listName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("(*v)[i] = item.ByteString")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("if item.ByteString == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected bytes, got %%s", plutusDataTypeString(item))`, listName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("(*v)[i] = item.ByteString")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if item.Integer == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected integer, got %%s", plutusDataTypeString(item))`, listName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("(*v)[i] = item.Integer")
			} else {
				goType := g.refToGoType(refName)
				// Check if it's an enum type
				unescaped := g.unescapeRef(refName)
				if def, ok := g.bp.Definitions[unescaped]; ok && def.IsEnum() {
					factoryFunc := goType + "FromPlutusData"
					g.writeLine(fmt.Sprintf("val, err := %s(item)", factoryFunc))
					g.writeLine("if err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine("(*v)[i] = val")
				} else {
					g.writeLine(fmt.Sprintf("var val %s", goType))
					g.writeLine("if err := val.FromPlutusData(item); err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine("(*v)[i] = val")
				}
			}
		}
	case innerSchema.IsInteger():
		g.writeLine("if item.Integer == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected integer, got %%s", plutusDataTypeString(item))`, listName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("(*v)[i] = item.Integer")
	case innerSchema.IsBytes():
		g.writeLine("if item.ByteString == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected bytes, got %%s", plutusDataTypeString(item))`, listName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("(*v)[i] = item.ByteString")
	default:
		g.writeLine("var val " + g.schemaToGoType(innerSchema))
		g.writeLine("if err := val.FromPlutusData(item); err != nil {")
		g.indentInc()
		g.writeLine("return err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("(*v)[i] = val")
	}
}

func (g *Generator) writeTupleFieldToPlutusData(fieldName string, item *Schema, index int) {
	switch {
	case item.IsRef():
		refName := item.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("items[%d] = NewIntPlutusData(v.%s)", index, fieldName))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("items[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("items[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("items[%d] = NewIntPlutusData(v.%s)", index, fieldName))
			} else {
				g.writeLine(fmt.Sprintf("item%d, err := v.%s.ToPlutusData()", index, fieldName))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: %%w", err)`, fieldName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("items[%d] = item%d", index, index))
			}
		}
	case item.IsInteger():
		g.writeLine(fmt.Sprintf("items[%d] = NewIntPlutusData(v.%s)", index, fieldName))
	case item.IsBytes():
		g.writeLine(fmt.Sprintf("items[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
	default:
		g.writeLine(fmt.Sprintf("item%d, err := v.%s.ToPlutusData()", index, fieldName))
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return PlutusData{}, fmt.Errorf("field %s: %%w", err)`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("items[%d] = item%d", index, index))
	}
}

func (g *Generator) writeTupleFieldFromPlutusData(fieldName string, item *Schema, index int) {
	switch {
	case item.IsRef():
		refName := item.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("if pd.List[%d].Integer == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].Integer", fieldName, index))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("if pd.List[%d].ByteString == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].ByteString", fieldName, index))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("if pd.List[%d].ByteString == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].ByteString", fieldName, index))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("if pd.List[%d].Integer == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].Integer", fieldName, index))
			} else {
				g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.List[%d]); err != nil {", fieldName, index))
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
			}
		}
	case item.IsInteger():
		g.writeLine(fmt.Sprintf("if pd.List[%d].Integer == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].Integer", fieldName, index))
	case item.IsBytes():
		g.writeLine(fmt.Sprintf("if pd.List[%d].ByteString == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].ByteString", fieldName, index))
	default:
		g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.List[%d]); err != nil {", fieldName, index))
		g.indentInc()
		g.writeLine("return err")
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeWrapperToPlutusData(name string, field *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()

	switch {
	case field.IsRef():
		refName := field.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewIntPlutusData(v.Value)), nil", constrIndex))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewBytesPlutusData(v.Value)), nil", constrIndex))
		case "Data":
			// Data type is raw PlutusData - pass through directly
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, v.Value), nil", constrIndex))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewBytesPlutusData(v.Value)), nil", constrIndex))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewIntPlutusData(v.Value)), nil", constrIndex))
			} else {
				g.writeLine("inner, err := v.Value.ToPlutusData()")
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(`return PlutusData{}, fmt.Errorf("Value: %w", err)`)
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, inner), nil", constrIndex))
			}
		}
	case field.IsInteger():
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewIntPlutusData(v.Value)), nil", constrIndex))
	case field.IsBytes():
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewBytesPlutusData(v.Value)), nil", constrIndex))
	default:
		g.writeLine("inner, err := v.Value.ToPlutusData()")
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine(`return PlutusData{}, fmt.Errorf("Value: %w", err)`)
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, inner), nil", constrIndex))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeWrapperFromPlutusData(name string, field *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()

	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("if pd.Constr.Index != %d {", constrIndex))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong constructor index for %s: expected %d, got %%d", pd.Constr.Index)`, name, constrIndex))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if len(pd.Constr.Fields) != 1 {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong number of fields for %s: expected 1, got %%d", len(pd.Constr.Fields))`, name))
	g.indentDec()
	g.writeLine("}")

	switch {
	case field.IsRef():
		refName := field.RefName()
		switch refName {
		case "Int":
			g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, name))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
		case "ByteArray":
			g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, name))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
		case "Data":
			// Data type is raw PlutusData - store directly
			g.writeLine("v.Value = pd.Constr.Fields[0]")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, name))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, name))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
			} else if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
				// Enum type - use factory function
				typeName := g.normalizeTypeName(refName)
				g.writeLine(fmt.Sprintf("innerVal, err := %sFromPlutusData(pd.Constr.Fields[0])", typeName))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: %%w", err)`, name))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = innerVal")
			} else {
				g.writeLine("if err := v.Value.FromPlutusData(pd.Constr.Fields[0]); err != nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: %%w", err)`, name))
				g.indentDec()
				g.writeLine("}")
			}
		}
	case field.IsInteger():
		g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, name))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
	case field.IsBytes():
		g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[0]))`, name))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
	default:
		g.writeLine("if err := v.Value.FromPlutusData(pd.Constr.Fields[0]); err != nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: %%w", err)`, name))
		g.indentDec()
		g.writeLine("}")
	}

	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeWrapperEquals(name string, field *Schema) {
	g.writeLine(fmt.Sprintf("func (v %s) Equals(other %s) bool {", name, name))
	g.indentInc()

	switch {
	case field.IsRef():
		refName := field.RefName()
		switch refName {
		case "Int":
			g.writeLine("if v.Value == nil && other.Value == nil {")
			g.indentInc()
			g.writeLine("return true")
			g.indentDec()
			g.writeLine("}")
			g.writeLine("if v.Value == nil || other.Value == nil {")
			g.indentInc()
			g.writeLine("return false")
			g.indentDec()
			g.writeLine("}")
			g.writeLine("return v.Value.Cmp(other.Value) == 0")
		case "ByteArray":
			g.writeLine("return bytes.Equal(v.Value, other.Value)")
		case "Bool":
			g.writeLine("return v.Value == other.Value")
		case "Data":
			g.writeLine("return v.Value.Equals(other.Value)")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("return bytes.Equal(v.Value, other.Value)")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if v.Value == nil && other.Value == nil {")
				g.indentInc()
				g.writeLine("return true")
				g.indentDec()
				g.writeLine("}")
				g.writeLine("if v.Value == nil || other.Value == nil {")
				g.indentInc()
				g.writeLine("return false")
				g.indentDec()
				g.writeLine("}")
				g.writeLine("return v.Value.Cmp(other.Value) == 0")
			} else if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
				typeName := g.normalizeTypeName(refName)
				g.writeLine(fmt.Sprintf("return %sEquals(v.Value, other.Value)", typeName))
			} else {
				g.writeLine("return v.Value.Equals(other.Value)")
			}
		}
	case field.IsInteger():
		g.writeLine("if v.Value == nil && other.Value == nil {")
		g.indentInc()
		g.writeLine("return true")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("if v.Value == nil || other.Value == nil {")
		g.indentInc()
		g.writeLine("return false")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("return v.Value.Cmp(other.Value) == 0")
	case field.IsBytes():
		g.writeLine("return bytes.Equal(v.Value, other.Value)")
	default:
		g.writeLine("return v.Value.Equals(other.Value)")
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

// schemaToGoType converts a schema to a Go type string.
func (g *Generator) schemaToGoType(schema *Schema) string {
	switch {
	case schema.IsRef():
		return g.refToGoType(schema.RefName())
	case schema.IsInteger():
		return "*big.Int"
	case schema.IsBytes():
		return "[]byte"
	case schema.IsList():
		if len(schema.Items) > 0 {
			if schema.Items.IsTuple() {
				return "[]interface{}"
			}
			itemType := g.schemaToGoType(schema.Items.Single())
			return "[]" + itemType
		}
		return "[]interface{}"
	case schema.IsMap():
		keyType := "string"
		if schema.Keys != nil {
			kt := g.schemaToGoType(schema.Keys)
			// []byte can't be a map key in Go, keep as string
			if kt != "[]byte" {
				keyType = kt
			}
		}
		valueType := "interface{}"
		if schema.Values != nil {
			valueType = g.schemaToGoType(schema.Values)
		}
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	case schema.IsBoolean():
		return "bool"
	case schema.IsUnit():
		return "struct{}"
	case schema.IsOption():
		// Option types use IsSet + Value struct, return the Option type name
		inner := schema.OptionInnerType()
		if inner != nil {
			innerGoType := g.schemaToGoType(inner)
			// Generate Option type name based on inner type
			innerTypeName := strings.TrimPrefix(innerGoType, "*")
			innerTypeName = strings.TrimPrefix(innerTypeName, "[]")
			// Capitalize first letter
			if len(innerTypeName) > 0 {
				innerTypeName = strings.ToUpper(innerTypeName[:1]) + innerTypeName[1:]
			}
			return "Option" + innerTypeName
		}
		return "OptionInterface"
	case schema.IsEnum():
		return "interface{}"
	case schema.IsOpaque() || schema.IsEmpty():
		return "interface{}" // Any Plutus data
	default:
		return "interface{}"
	}
}

func (g *Generator) refToGoType(refName string) string {
	switch refName {
	case "Int":
		return "*big.Int"
	case "ByteArray":
		return "[]byte"
	case "Bool":
		return "bool"
	case "Data":
		return "PlutusData"
	case "Void":
		return "struct{}"
	default:
		if strings.HasPrefix(refName, "List$") {
			// Extract inner type
			inner := strings.TrimPrefix(refName, "List$")
			inner = strings.ReplaceAll(inner, "~1", "/")
			return "[]" + g.refToGoType(inner)
		}
		if strings.HasPrefix(refName, "Option$") {
			// Option types - return the Option type name (with IsSet + Value)
			// Normalize the name to get the generated type name
			return g.normalizeTypeName(refName)
		}
		if strings.HasPrefix(refName, "Pairs$") {
			return g.pairsToGoType(refName)
		}

		// Check if the referenced type is actually a primitive wrapper
		unescaped := g.unescapeRef(refName)
		if def, ok := g.bp.Definitions[unescaped]; ok {
			if def.IsBytes() {
				return "[]byte"
			}
			if def.IsInteger() {
				return "*big.Int"
			}
		}

		// All other types - normalize the name
		return g.normalizeTypeName(refName)
	}
}

func (g *Generator) pairsToGoType(refName string) string {
	inner := strings.TrimPrefix(refName, "Pairs$")
	inner = strings.ReplaceAll(inner, "~1", "/")
	parts := strings.SplitN(inner, "_", 2)
	if len(parts) != 2 {
		return "map[string]interface{}"
	}
	keyType := g.refToGoType(parts[0])
	// []byte can't be a map key in Go, keep as string
	if keyType == "[]byte" {
		keyType = "string"
	}
	valueType := g.refToGoType(parts[1])
	return fmt.Sprintf("map[%s]%s", keyType, valueType)
}

// Helper functions

func (g *Generator) normalizeTypeName(name string) string {
	// Handle prefixes like Option$, List$, etc.
	// Examples:
	//   Option$string_validator/SimpleString -> OptionStringValidatorSimpleString
	//   Option$custom/Credential -> OptionCustomCredential
	//   v0_3/types/Settings -> V03TypesSettings
	//   Option$Int -> OptionInt
	//   List$Int -> ListInt

	// First, unescape URL-encoded characters (~1 = /, ~0 = ~)
	name = strings.ReplaceAll(name, "~1", "/")
	name = strings.ReplaceAll(name, "~0", "~")

	// Check if there's a $ in the name (prefix type)
	if idx := strings.Index(name, "$"); idx >= 0 {
		prefix := name[:idx]
		rest := name[idx+1:]
		// Get the inner type name
		innerName := g.normalizeTypeName(rest)
		return g.toGoIdentifier(prefix) + innerName
	}

	// Include the full path to avoid name collisions
	// e.g., v0_3/types/Settings -> V03TypesSettings
	parts := strings.Split(name, "/")
	var result strings.Builder
	for _, part := range parts {
		result.WriteString(g.toGoIdentifier(part))
	}
	return result.String()
}

func (g *Generator) normalizeFieldName(name string, index int) string {
	if name == "" {
		return fmt.Sprintf("Field%d", index)
	}
	return g.toGoIdentifier(name)
}

func (g *Generator) toGoIdentifier(s string) string {
	if s == "" {
		return ""
	}
	// Remove or replace characters invalid in Go identifiers
	// Valid: letters, digits, underscore (but can't start with digit)
	s = strings.ReplaceAll(s, "/", "_")
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, " ", "_")
	s = g.snakeToCamel(s)
	runes := []rune(s)
	if len(runes) > 0 {
		runes[0] = unicode.ToUpper(runes[0])
	}
	return string(runes)
}

func (g *Generator) snakeToCamel(s string) string {
	if !strings.Contains(s, "_") {
		if len(s) > 0 {
			return strings.ToUpper(s[:1]) + s[1:]
		}
		return s
	}
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return strings.Join(parts, "")
}

func (g *Generator) unescapeRef(ref string) string {
	// Handle JSON Pointer escaping: ~1 = /, ~0 = ~
	ref = strings.ReplaceAll(ref, "~1", "/")
	ref = strings.ReplaceAll(ref, "~0", "~")
	return ref
}

func (g *Generator) isStandardTypeName(name string) bool {
	// Only skip truly primitive types that don't have definitions
	switch name {
	case "Int", "ByteArray", "Data", "Void", "Bool":
		return true
	default:
		return false
	}
}

// isPrimitiveWrapper checks if the referenced type is a primitive wrapper (e.g., PolicyId -> bytes)
func (g *Generator) isPrimitiveWrapper(refName string, primitiveType string) bool {
	unescaped := g.unescapeRef(refName)
	if def, ok := g.bp.Definitions[unescaped]; ok {
		switch primitiveType {
		case "bytes":
			return def.IsBytes()
		case "integer":
			return def.IsInteger()
		}
	}
	return false
}

// Output helpers

func (g *Generator) writeLine(s string) {
	for i := 0; i < g.indent; i++ {
		g.buf.WriteString("\t")
	}
	g.buf.WriteString(s)
	g.buf.WriteString("\n")
}

func (g *Generator) indentInc() {
	g.indent++
}

func (g *Generator) indentDec() {
	if g.indent > 0 {
		g.indent--
	}
}
