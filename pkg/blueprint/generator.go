package blueprint

import (
	"fmt"
	"sort"
	"strings"
	"unicode"
)

// GeneratorOptions configures the code generator.
type GeneratorOptions struct {
	// PackageName is the Go package name for generated code.
	PackageName string
}

// Generator produces Go source code from a Blueprint.
type Generator struct {
	bp         *Blueprint
	opts       GeneratorOptions
	buf        strings.Builder
	indent     int
	generated  map[string]bool // track which types have been generated
}

// NewGenerator creates a new code generator.
func NewGenerator(bp *Blueprint, opts GeneratorOptions) *Generator {
	if opts.PackageName == "" {
		opts.PackageName = "contracts"
	}
	return &Generator{
		bp:        bp,
		opts:      opts,
		generated: make(map[string]bool),
	}
}

// Generate produces Go source code from the blueprint.
func (g *Generator) Generate() (string, error) {
	g.writeHeader()
	g.writeImports()
	g.writeLine("")

	// Generate type definitions
	if err := g.writeTypeDefinitions(); err != nil {
		return "", err
	}

	return g.buf.String(), nil
}

func (g *Generator) writeHeader() {
	g.writeLine("// Code generated by aiken2go. DO NOT EDIT.")
	g.writeLine(fmt.Sprintf("// Source: %s", g.bp.Preamble.Title))
	g.writeLine("")
	g.writeLine(fmt.Sprintf("package %s", g.opts.PackageName))
}

func (g *Generator) writeImports() {
	g.writeLine("")
	g.writeLine("import (")
	g.indentInc()
	g.writeLine(`"bytes"`)
	g.writeLine(`"errors"`)
	g.writeLine(`"fmt"`)
	g.writeLine(`"math/big"`)
	g.writeLine("")
	g.writeLine(`"github.com/fxamacker/cbor/v2"`)
	g.indentDec()
	g.writeLine(")")
	g.writeLine("")
	g.writePlutusDataTypes()
	g.writeHelpers()
}

func (g *Generator) writePlutusDataTypes() {
	// PlutusData types - embedded directly in generated code
	g.writeLine("// PlutusData represents a Plutus Data value that can be serialized to CBOR.")
	g.writeLine("type PlutusData struct {")
	g.indentInc()
	g.writeLine("Constr     *ConstrPlutusData")
	g.writeLine("Integer    *big.Int")
	g.writeLine("ByteString []byte")
	g.writeLine("List       []PlutusData")
	g.writeLine("Map        []PlutusDataMapEntry")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// ConstrPlutusData represents a constructor with an index and fields.")
	g.writeLine("type ConstrPlutusData struct {")
	g.indentInc()
	g.writeLine("Index  uint64")
	g.writeLine("Fields []PlutusData")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// PlutusDataMapEntry represents a key-value pair in a Plutus Data map.")
	g.writeLine("type PlutusDataMapEntry struct {")
	g.indentInc()
	g.writeLine("Key   PlutusData")
	g.writeLine("Value PlutusData")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Constants
	g.writeLine("const (")
	g.indentInc()
	g.writeLine("cborTagConstr0    = 121")
	g.writeLine("cborTagConstr6    = 127")
	g.writeLine("cborTagConstrBase = 1280")
	g.indentDec()
	g.writeLine(")")
	g.writeLine("")

	// Constructor functions
	g.writeLine("// NewConstrPlutusData creates a new constructor PlutusData.")
	g.writeLine("func NewConstrPlutusData(index uint64, fields ...PlutusData) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{Constr: &ConstrPlutusData{Index: index, Fields: fields}}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// NewIntPlutusData creates a new integer PlutusData.")
	g.writeLine("func NewIntPlutusData(i *big.Int) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: i}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// NewBytesPlutusData creates a new bytestring PlutusData.")
	g.writeLine("func NewBytesPlutusData(b []byte) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{ByteString: b}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	g.writeLine("// NewListPlutusData creates a new list PlutusData.")
	g.writeLine("func NewListPlutusData(items ...PlutusData) PlutusData {")
	g.indentInc()
	g.writeLine("return PlutusData{List: items}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// MarshalCBOR - uses indefinite-length arrays to match Aiken's CBOR format
	g.writeLine("// MarshalCBOR serializes PlutusData to CBOR bytes using indefinite-length arrays.")
	g.writeLine("func (p PlutusData) MarshalCBOR() ([]byte, error) {")
	g.indentInc()
	g.writeLine("return p.toCBORBytes()")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// UnmarshalCBOR
	g.writeLine("// UnmarshalCBOR deserializes PlutusData from CBOR bytes.")
	g.writeLine("func (p *PlutusData) UnmarshalCBOR(data []byte) error {")
	g.indentInc()
	g.writeLine("dm, err := cbor.DecOptions{BigIntDec: cbor.BigIntDecodePointer}.DecMode()")
	g.writeLine("if err != nil { return err }")
	g.writeLine("var raw interface{}")
	g.writeLine("if err := dm.Unmarshal(data, &raw); err != nil { return err }")
	g.writeLine("result, err := plutusDataFromCBORValue(raw)")
	g.writeLine("if err != nil { return err }")
	g.writeLine("*p = result")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// toCBORBytes - produces CBOR bytes with indefinite-length arrays (Aiken format)
	g.writeLine("func (p PlutusData) toCBORBytes() ([]byte, error) {")
	g.indentInc()
	g.writeLine("em, err := cbor.EncOptions{BigIntConvert: cbor.BigIntConvertShortest}.EncMode()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("switch {")
	g.writeLine("case p.Constr != nil:")
	g.indentInc()
	g.writeLine("var buf bytes.Buffer")
	g.writeLine("// Encode constructor tag")
	g.writeLine("var tag uint64")
	g.writeLine("if p.Constr.Index <= 6 { tag = cborTagConstr0 + p.Constr.Index } else { tag = cborTagConstrBase + p.Constr.Index - 7 }")
	g.writeLine("// Write CBOR tag header (minimal encoding)")
	g.writeLine("if tag < 24 { buf.WriteByte(0xc0 + byte(tag)) } else if tag < 256 { buf.WriteByte(0xd8); buf.WriteByte(byte(tag)) } else { buf.WriteByte(0xd9); buf.WriteByte(byte(tag >> 8)); buf.WriteByte(byte(tag)) }")
	g.writeLine("// Empty arrays use definite-length encoding, non-empty use indefinite")
	g.writeLine("if len(p.Constr.Fields) == 0 {")
	g.indentInc()
	g.writeLine("buf.WriteByte(0x80) // empty array")
	g.indentDec()
	g.writeLine("} else {")
	g.indentInc()
	g.writeLine("buf.WriteByte(0x9f) // indefinite-length array start")
	g.writeLine("for _, f := range p.Constr.Fields {")
	g.indentInc()
	g.writeLine("fieldBytes, err := f.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(fieldBytes)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("buf.WriteByte(0xff) // break")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return buf.Bytes(), nil")
	g.indentDec()
	g.writeLine("case p.Integer != nil:")
	g.indentInc()
	g.writeLine("return em.Marshal(p.Integer)")
	g.indentDec()
	g.writeLine("case p.ByteString != nil:")
	g.indentInc()
	g.writeLine("return em.Marshal(p.ByteString)")
	g.indentDec()
	g.writeLine("case p.List != nil:")
	g.indentInc()
	g.writeLine("var buf bytes.Buffer")
	g.writeLine("// Write indefinite-length array start")
	g.writeLine("buf.WriteByte(0x9f)")
	g.writeLine("for _, item := range p.List {")
	g.indentInc()
	g.writeLine("itemBytes, err := item.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(itemBytes)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("// Write indefinite-length array end (break)")
	g.writeLine("buf.WriteByte(0xff)")
	g.writeLine("return buf.Bytes(), nil")
	g.indentDec()
	g.writeLine("case p.Map != nil:")
	g.indentInc()
	g.writeLine("var buf bytes.Buffer")
	g.writeLine("// Write indefinite-length map start")
	g.writeLine("buf.WriteByte(0xbf)")
	g.writeLine("for _, entry := range p.Map {")
	g.indentInc()
	g.writeLine("keyBytes, err := entry.Key.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(keyBytes)")
	g.writeLine("valBytes, err := entry.Value.toCBORBytes()")
	g.writeLine("if err != nil { return nil, err }")
	g.writeLine("buf.Write(valBytes)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("// Write indefinite-length map end (break)")
	g.writeLine("buf.WriteByte(0xff)")
	g.writeLine("return buf.Bytes(), nil")
	g.indentDec()
	g.writeLine("default:")
	g.indentInc()
	g.writeLine("// Empty constructor 0")
	g.writeLine("return []byte{0xd8, 0x79, 0x9f, 0xff}, nil")
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// fromCBORValue
	g.writeLine("func plutusDataFromCBORValue(v interface{}) (PlutusData, error) {")
	g.indentInc()
	g.writeLine("switch val := v.(type) {")
	g.writeLine("case cbor.Tag:")
	g.indentInc()
	g.writeLine("var index uint64")
	g.writeLine("switch {")
	g.writeLine("case val.Number >= cborTagConstr0 && val.Number <= cborTagConstr6: index = val.Number - cborTagConstr0")
	g.writeLine("case val.Number >= cborTagConstrBase: index = val.Number - cborTagConstrBase + 7")
	g.writeLine(`default: return PlutusData{}, fmt.Errorf("unsupported CBOR tag: %d", val.Number)`)
	g.writeLine("}")
	g.writeLine("content, ok := val.Content.([]interface{}); if !ok { return PlutusData{}, errors.New(\"constructor content is not an array\") }")
	g.writeLine("fields := make([]PlutusData, len(content))")
	g.writeLine("for i, item := range content { pd, err := plutusDataFromCBORValue(item); if err != nil { return PlutusData{}, err }; fields[i] = pd }")
	g.writeLine("return PlutusData{Constr: &ConstrPlutusData{Index: index, Fields: fields}}, nil")
	g.indentDec()
	g.writeLine("case *big.Int:")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: val}, nil")
	g.indentDec()
	g.writeLine("case int64:")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: big.NewInt(val)}, nil")
	g.indentDec()
	g.writeLine("case uint64:")
	g.indentInc()
	g.writeLine("return PlutusData{Integer: new(big.Int).SetUint64(val)}, nil")
	g.indentDec()
	g.writeLine("case []byte:")
	g.indentInc()
	g.writeLine("return PlutusData{ByteString: val}, nil")
	g.indentDec()
	g.writeLine("case []interface{}:")
	g.indentInc()
	g.writeLine("items := make([]PlutusData, len(val))")
	g.writeLine("for i, item := range val { pd, err := plutusDataFromCBORValue(item); if err != nil { return PlutusData{}, err }; items[i] = pd }")
	g.writeLine("return PlutusData{List: items}, nil")
	g.indentDec()
	g.writeLine("case map[interface{}]interface{}:")
	g.indentInc()
	g.writeLine("entries := make([]PlutusDataMapEntry, 0, len(val))")
	g.writeLine("for k, v := range val {")
	g.indentInc()
	g.writeLine("key, err := plutusDataFromCBORValue(k); if err != nil { return PlutusData{}, err }")
	g.writeLine("value, err := plutusDataFromCBORValue(v); if err != nil { return PlutusData{}, err }")
	g.writeLine("entries = append(entries, PlutusDataMapEntry{Key: key, Value: value})")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return PlutusData{Map: entries}, nil")
	g.indentDec()
	g.writeLine("case nil:")
	g.indentInc()
	g.writeLine("// CBOR null - not standard PlutusData, but some serializers use it")
	g.writeLine("// Treat as Void/Unit (constructor 0 with no fields)")
	g.writeLine("return PlutusData{Constr: &ConstrPlutusData{Index: 0, Fields: []PlutusData{}}}, nil")
	g.indentDec()
	g.writeLine("default:")
	g.indentInc()
	g.writeLine(`return PlutusData{}, fmt.Errorf("unsupported CBOR type: %T", v)`)
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// ToHex
	g.writeLine("// ToHex returns the CBOR encoding as a hex string.")
	g.writeLine("func (p PlutusData) ToHex() (string, error) {")
	g.indentInc()
	g.writeLine("data, err := p.MarshalCBOR(); if err != nil { return \"\", err }")
	g.writeLine("return fmt.Sprintf(\"%x\", data), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Equals
	g.writeLine("// Equals compares two PlutusData values for equality.")
	g.writeLine("func (p PlutusData) Equals(other PlutusData) bool {")
	g.indentInc()
	g.writeLine("a, err := p.MarshalCBOR(); if err != nil { return false }")
	g.writeLine("b, err := other.MarshalCBOR(); if err != nil { return false }")
	g.writeLine("return bytes.Equal(a, b)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeHelpers() {
	// plutusDataTypeString helper - describes the type of a PlutusData for error messages
	g.writeLine("func plutusDataTypeString(pd PlutusData) string {")
	g.indentInc()
	g.writeLine("switch {")
	g.writeLine("case pd.Constr != nil:")
	g.indentInc()
	g.writeLine(`return fmt.Sprintf("constructor(%d)", pd.Constr.Index)`)
	g.indentDec()
	g.writeLine("case pd.Integer != nil:")
	g.indentInc()
	g.writeLine(`return "integer"`)
	g.indentDec()
	g.writeLine("case pd.ByteString != nil:")
	g.indentInc()
	g.writeLine(`return "bytes"`)
	g.indentDec()
	g.writeLine("case pd.List != nil:")
	g.indentInc()
	g.writeLine(`return "list"`)
	g.indentDec()
	g.writeLine("case pd.Map != nil:")
	g.indentInc()
	g.writeLine(`return "map"`)
	g.indentDec()
	g.writeLine("default:")
	g.indentInc()
	g.writeLine(`return "null"`)
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Suppress unused variable warnings
	g.writeLine("var _ = errors.New")
	g.writeLine("var _ = big.NewInt")
	g.writeLine("var _ = PlutusData{}")
}

func (g *Generator) writeTypeDefinitions() error {
	// Sort definition names for deterministic output
	names := make([]string, 0, len(g.bp.Definitions))
	for name := range g.bp.Definitions {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		schema := g.bp.Definitions[name]
		if g.isStandardTypeName(name) {
			continue
		}
		// Skip List$ and Pairs$ types as they're handled inline
		// But generate Tuple$ types as structs
		if strings.HasPrefix(name, "List$") || strings.HasPrefix(name, "Pairs$") {
			continue
		}
		if err := g.writeTypeDef(name, schema); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) writeTypeDef(name string, schema *Schema) error {
	goName := g.normalizeTypeName(name)

	// Skip if already generated
	if g.generated[goName] {
		return nil
	}

	// Handle different schema types
	// Only mark as generated AFTER we confirm we will generate something
	switch {
	case schema.IsBoolean():
		// Generate Bool enum type with BoolFromPlutusData
		g.generated[goName] = true
		return g.writeBoolType(goName, schema)
	case schema.IsUnit():
		// Generate empty struct for Unit/Void
		g.generated[goName] = true
		g.writeUnitType(goName)
		return nil
	case schema.IsOption():
		// Option types are now handled as pointers, no separate type needed
		g.generated[goName] = true
		return nil
	case schema.IsSingleConstructor():
		// Single constructor - generate struct
		g.generated[goName] = true
		return g.writeStructType(goName, &schema.AnyOf[0], 0)
	case schema.IsEnum():
		// Multiple constructors - generate interface + variants
		g.generated[goName] = true
		return g.writeEnumType(goName, schema)
	case schema.IsConstructor():
		// Direct constructor
		g.generated[goName] = true
		return g.writeStructType(goName, schema, 0)
	case schema.IsList() && len(schema.Items) > 1:
		// Tuple type (list with multiple items)
		g.generated[goName] = true
		return g.writeTupleType(goName, schema)
	case schema.IsList() && len(schema.Items) == 1:
		// Named list type (single item) - generate type alias
		g.generated[goName] = true
		return g.writeListTypeAlias(goName, schema)
	default:
		// Primitive or reference - skip (handled inline)
		// Don't mark as generated since we're not generating anything
		return nil
	}
}

func (g *Generator) writeUnitType(name string) {
	g.writeLine(fmt.Sprintf("// %s represents the Aiken Void/Unit type.", name))
	g.writeLine(fmt.Sprintf("type %s struct{}", name))
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine("return NewConstrPlutusData(0), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(`return errors.New("expected constructor for Unit type")`)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if pd.Constr.Index != 0 {")
	g.indentInc()
	g.writeLine(`return fmt.Errorf("wrong constructor index for Unit type: expected 0, got %d", pd.Constr.Index)`)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if len(pd.Constr.Fields) != 0 {")
	g.indentInc()
	g.writeLine(`return fmt.Errorf("wrong number of fields for Unit type: expected 0, got %d", len(pd.Constr.Fields))`)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeBoolType(name string, _ *Schema) error {
	// Bool is an enum with False (0) and True (1) constructors
	g.writeLine(fmt.Sprintf("// %s represents the Aiken Bool type.", name))
	g.writeLine(fmt.Sprintf("type %s bool", name))
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine("if v {")
	g.indentInc()
	g.writeLine("return NewConstrPlutusData(1), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return NewConstrPlutusData(0), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData method
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("*v = pd.Constr.Index == 1")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData function
	g.writeLine(fmt.Sprintf("// %sFromPlutusData decodes a %s from PlutusData.", name, name))
	g.writeLine(fmt.Sprintf("func %sFromPlutusData(pd PlutusData) (%s, error) {", name, name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return false, errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("return %s(pd.Constr.Index == 1), nil", name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	return nil
}

func (g *Generator) writeStructType(name string, schema *Schema, constrIndex int) error {
	// Documentation
	if schema.Title != "" {
		g.writeLine(fmt.Sprintf("// %s represents the Aiken %s type.", name, schema.Title))
	}

	// Struct definition
	g.writeLine(fmt.Sprintf("type %s struct {", name))
	g.indentInc()

	for i, field := range schema.Fields {
		fieldName := g.normalizeFieldName(field.Title, i)
		fieldType := g.schemaToGoType(&field)
		g.writeLine(fmt.Sprintf("%s %s", fieldName, fieldType))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Generate ToPlutusData method
	g.writeStructToPlutusData(name, schema, constrIndex)

	// Generate FromPlutusData method
	g.writeStructFromPlutusData(name, schema, constrIndex)

	return nil
}

func (g *Generator) writeStructToPlutusData(name string, schema *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()

	if len(schema.Fields) == 0 {
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d), nil", constrIndex))
	} else {
		g.writeLine(fmt.Sprintf("fields := make([]PlutusData, %d)", len(schema.Fields)))
		for i, field := range schema.Fields {
			fieldName := g.normalizeFieldName(field.Title, i)
			g.writeFieldToPlutusData(fieldName, &field, i)
		}
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, fields...), nil", constrIndex))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeFieldToPlutusData(fieldName string, schema *Schema, index int) {
	switch {
	case schema.IsRef():
		refName := schema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("fields[%d] = NewIntPlutusData(v.%s)", index, fieldName))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("fields[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
		case "Bool":
			g.writeLine(fmt.Sprintf("if v.%s {", fieldName))
			g.indentInc()
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index))
			g.indentDec()
			g.writeLine("} else {")
			g.indentInc()
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0)", index))
			g.indentDec()
			g.writeLine("}")
		case "Data":
			// Data type is raw PlutusData
			g.writeLine(fmt.Sprintf("fields[%d] = v.%s", index, fieldName))
		default:
			if strings.HasPrefix(refName, "List$") {
				// List type - handle inline
				g.writeListFieldToPlutusData(fieldName, refName, index)
			} else if strings.HasPrefix(refName, "Pairs$") {
				// Map type - skip for now (complex)
				g.writeLine(fmt.Sprintf("// TODO: Map serialization for %s", fieldName))
				g.writeLine(fmt.Sprintf("fields[%d] = PlutusData{}", index))
			} else if strings.HasPrefix(refName, "Option$") {
				// Option type - handle as pointer
				g.writeOptionRefToPlutusData(fieldName, refName, index)
			} else if g.isPrimitiveWrapper(refName, "bytes") {
				// Primitive wrapper for bytes
				g.writeLine(fmt.Sprintf("fields[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				// Primitive wrapper for integer
				g.writeLine(fmt.Sprintf("fields[%d] = NewIntPlutusData(v.%s)", index, fieldName))
			} else {
				// Custom type with ToPlutusData
				g.writeLine(fmt.Sprintf("field%d, err := v.%s.ToPlutusData()", index, fieldName))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return PlutusData{}, err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("fields[%d] = field%d", index, index))
			}
		}
	case schema.IsInteger():
		g.writeLine(fmt.Sprintf("fields[%d] = NewIntPlutusData(v.%s)", index, fieldName))
	case schema.IsBytes():
		g.writeLine(fmt.Sprintf("fields[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
	case schema.IsList():
		g.writeLine(fmt.Sprintf("list%d := make([]PlutusData, len(v.%s))", index, fieldName))
		g.writeLine(fmt.Sprintf("for i, item := range v.%s {", fieldName))
		g.indentInc()
		if len(schema.Items) > 0 && schema.Items.Single() != nil {
			itemSchema := schema.Items.Single()
			g.writeListItemToPlutusData(itemSchema, index)
		} else {
			g.writeLine("itemPd, err := item.ToPlutusData()")
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine("return PlutusData{}, err")
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("list%d[i] = itemPd", index))
		}
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("fields[%d] = NewListPlutusData(list%d...)", index, index))
	case schema.IsMap():
		// Map type - skip for now
		g.writeLine(fmt.Sprintf("// TODO: Map serialization for %s", fieldName))
		g.writeLine(fmt.Sprintf("fields[%d] = PlutusData{}", index))
	case schema.IsBoolean():
		g.writeLine(fmt.Sprintf("if v.%s {", fieldName))
		g.indentInc()
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index))
		g.indentDec()
		g.writeLine("} else {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0)", index))
		g.indentDec()
		g.writeLine("}")
	case schema.IsOption():
		inner := schema.OptionInnerType()
		g.writeLine(fmt.Sprintf("if v.%s != nil {", fieldName))
		g.indentInc()
		if inner != nil && (inner.IsRef() || inner.IsInteger() || inner.IsBytes()) {
			// Simple inner type
			g.writeOptionSomeValue(fieldName, inner, index)
		} else {
			g.writeLine(fmt.Sprintf("innerPd, err := v.%s.ToPlutusData()", fieldName))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine("return PlutusData{}, err")
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, innerPd)", index))
		}
		g.indentDec()
		g.writeLine("} else {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index)) // None
		g.indentDec()
		g.writeLine("}")
	default:
		// Custom type
		g.writeLine(fmt.Sprintf("field%d, err := v.%s.ToPlutusData()", index, fieldName))
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine("return PlutusData{}, err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("fields[%d] = field%d", index, index))
	}
}

func (g *Generator) writeListFieldToPlutusData(fieldName, refName string, index int) {
	// Extract inner type from List$Type
	inner := strings.TrimPrefix(refName, "List$")
	inner = strings.ReplaceAll(inner, "~1", "/")

	g.writeLine(fmt.Sprintf("list%d := make([]PlutusData, len(v.%s))", index, fieldName))
	g.writeLine(fmt.Sprintf("for i, item := range v.%s {", fieldName))
	g.indentInc()

	switch inner {
	case "Int":
		g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", index))
	case "ByteArray":
		g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", index))
	case "Bool":
		g.writeLine("if item {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(1)", index))
		g.indentDec()
		g.writeLine("} else {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(0)", index))
		g.indentDec()
		g.writeLine("}")
	default:
		if g.isPrimitiveWrapper(inner, "bytes") {
			g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", index))
		} else if g.isPrimitiveWrapper(inner, "integer") {
			g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", index))
		} else {
			g.writeLine("itemPd, err := item.ToPlutusData()")
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine("return PlutusData{}, err")
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("list%d[i] = itemPd", index))
		}
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("fields[%d] = NewListPlutusData(list%d...)", index, index))
}

func (g *Generator) writeListItemToPlutusData(itemSchema *Schema, listIndex int) {
	switch {
	case itemSchema.IsRef():
		refName := itemSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", listIndex))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", listIndex))
		case "Bool":
			g.writeLine("if item {")
			g.indentInc()
			g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(1)", listIndex))
			g.indentDec()
			g.writeLine("} else {")
			g.indentInc()
			g.writeLine(fmt.Sprintf("list%d[i] = NewConstrPlutusData(0)", listIndex))
			g.indentDec()
			g.writeLine("}")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", listIndex))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", listIndex))
			} else {
				g.writeLine("itemPd, err := item.ToPlutusData()")
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return PlutusData{}, err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("list%d[i] = itemPd", listIndex))
			}
		}
	case itemSchema.IsInteger():
		g.writeLine(fmt.Sprintf("list%d[i] = NewIntPlutusData(item)", listIndex))
	case itemSchema.IsBytes():
		g.writeLine(fmt.Sprintf("list%d[i] = NewBytesPlutusData(item)", listIndex))
	default:
		g.writeLine("itemPd, err := item.ToPlutusData()")
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine("return PlutusData{}, err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("list%d[i] = itemPd", listIndex))
	}
}

func (g *Generator) writeOptionSomeValue(fieldName string, inner *Schema, index int) {
	switch {
	case inner.IsRef():
		refName := inner.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s))", index, fieldName))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(*v.%s))", index, fieldName))
		default:
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(*v.%s))", index, fieldName))
		}
	case inner.IsInteger():
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s))", index, fieldName))
	case inner.IsBytes():
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(*v.%s))", index, fieldName))
	}
}

func (g *Generator) writeOptionRefToPlutusData(fieldName string, refName string, index int) {
	// Extract inner type from Option$InnerType
	innerRef := strings.TrimPrefix(refName, "Option$")
	innerRef = strings.ReplaceAll(innerRef, "~1", "/")

	g.writeLine(fmt.Sprintf("if v.%s != nil {", fieldName))
	g.indentInc()

	switch innerRef {
	case "Int":
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s))", index, fieldName))
	case "ByteArray":
		g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(*v.%s))", index, fieldName))
	default:
		if g.isPrimitiveWrapper(innerRef, "bytes") {
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewBytesPlutusData(*v.%s))", index, fieldName))
		} else if g.isPrimitiveWrapper(innerRef, "integer") {
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, NewIntPlutusData(v.%s))", index, fieldName))
		} else {
			// Complex inner type - call ToPlutusData
			g.writeLine(fmt.Sprintf("innerPd, err := v.%s.ToPlutusData()", fieldName))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine("return PlutusData{}, err")
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(0, innerPd)", index))
		}
	}

	g.indentDec()
	g.writeLine("} else {")
	g.indentInc()
	g.writeLine(fmt.Sprintf("fields[%d] = NewConstrPlutusData(1)", index)) // None
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeOptionRefFromPlutusData(fieldName string, refName string, index int) {
	// Extract inner type from Option$InnerType
	innerRef := strings.TrimPrefix(refName, "Option$")
	innerRef = strings.ReplaceAll(innerRef, "~1", "/")
	goType := g.refToGoType(innerRef)

	// Check if it's a constructor (Option is encoded as constructor 0 for Some, 1 for None)
	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected Option constructor, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
	g.indentDec()
	g.writeLine("}")

	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Index == 1 {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf("v.%s = nil // None", fieldName))
	g.indentDec()
	g.writeLine(fmt.Sprintf("} else if pd.Constr.Fields[%d].Constr.Index == 0 {", index))
	g.indentInc()

	// Check that Some has exactly 1 field
	g.writeLine(fmt.Sprintf("if len(pd.Constr.Fields[%d].Constr.Fields) != 1 {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: Option Some should have 1 field, got %%d", len(pd.Constr.Fields[%d].Constr.Fields))`, fieldName, index))
	g.indentDec()
	g.writeLine("}")

	// Extract the inner value based on type
	switch innerRef {
	case "Int":
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].Integer == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Constr.Fields[0].Integer", fieldName, index))
	case "ByteArray":
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].ByteString == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("optVal := pd.Constr.Fields[%d].Constr.Fields[0].ByteString", index))
		g.writeLine(fmt.Sprintf("v.%s = &optVal", fieldName))
	default:
		if g.isPrimitiveWrapper(innerRef, "bytes") {
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].ByteString == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("optVal := pd.Constr.Fields[%d].Constr.Fields[0].ByteString", index))
			g.writeLine(fmt.Sprintf("v.%s = &optVal", fieldName))
		} else if g.isPrimitiveWrapper(innerRef, "integer") {
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr.Fields[0].Integer == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer in Option Some, got %%s", plutusDataTypeString(pd.Constr.Fields[%d].Constr.Fields[0]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Constr.Fields[0].Integer", fieldName, index))
		} else {
			// Check if it's an enum type (interface)
			unescaped := g.unescapeRef(innerRef)
			if def, ok := g.bp.Definitions[unescaped]; ok && def.IsEnum() && !def.IsSingleConstructor() {
				// Enum type - use factory function
				typeName := g.normalizeTypeName(innerRef)
				g.writeLine(fmt.Sprintf("%sVal, err := %sFromPlutusData(pd.Constr.Fields[%d].Constr.Fields[0])", fieldName, typeName, index))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = %sVal", fieldName, fieldName))
			} else {
				// Complex inner type - allocate and call FromPlutusData
				g.writeLine(fmt.Sprintf("v.%s = new(%s)", fieldName, goType))
				g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.Constr.Fields[%d].Constr.Fields[0]); err != nil {", fieldName, index))
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
			}
		}
	}

	g.indentDec()
	g.writeLine("} else {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: unknown Option constructor index %%d", pd.Constr.Fields[%d].Constr.Index)`, fieldName, index))
	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeStructFromPlutusData(name string, schema *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()

	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")

	g.writeLine(fmt.Sprintf("if pd.Constr.Index != %d {", constrIndex))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong constructor index for %s: expected %d, got %%d", pd.Constr.Index)`, name, constrIndex))
	g.indentDec()
	g.writeLine("}")

	if len(schema.Fields) > 0 {
		g.writeLine(fmt.Sprintf("if len(pd.Constr.Fields) != %d {", len(schema.Fields)))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong number of fields for %s: expected %d, got %%d", len(pd.Constr.Fields))`, name, len(schema.Fields)))
		g.indentDec()
		g.writeLine("}")

		for i, field := range schema.Fields {
			fieldName := g.normalizeFieldName(field.Title, i)
			g.writeFieldFromPlutusData(fieldName, &field, i)
		}
	}

	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeFieldFromPlutusData(fieldName string, schema *Schema, index int) {
	switch {
	case schema.IsRef():
		refName := schema.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Integer == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Integer", fieldName, index))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].ByteString == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].ByteString", fieldName, index))
		case "Bool":
			g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected constructor for bool, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Constr.Index == 1", fieldName, index))
		case "Data":
			// Data type is raw PlutusData - store directly
			g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d]", fieldName, index))
		default:
			if strings.HasPrefix(refName, "List$") {
				// List type - handle inline
				g.writeListFieldFromPlutusData(fieldName, refName, index)
			} else if strings.HasPrefix(refName, "Pairs$") {
				// Map type - skip for now
				g.writeLine(fmt.Sprintf("// TODO: Map deserialization for %s", fieldName))
			} else if strings.HasPrefix(refName, "Option$") {
				// Option type - handle as pointer
				g.writeOptionRefFromPlutusData(fieldName, refName, index)
			} else if g.isPrimitiveWrapper(refName, "bytes") {
				// Primitive wrapper for bytes
				g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].ByteString == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].ByteString", fieldName, index))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				// Primitive wrapper for integer
				g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Integer == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Integer", fieldName, index))
			} else {
				// Check if it's an enum type
				if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					typeName := g.normalizeTypeName(refName)
					g.writeLine(fmt.Sprintf("%sVal, err := %sFromPlutusData(pd.Constr.Fields[%d])", fieldName, typeName, index))
					g.writeLine("if err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine(fmt.Sprintf("v.%s = %sVal", fieldName, fieldName))
				} else {
					g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.Constr.Fields[%d]); err != nil {", fieldName, index))
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
				}
			}
		}
	case schema.IsInteger():
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Integer == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Integer", fieldName, index))
	case schema.IsBytes():
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].ByteString == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].ByteString", fieldName, index))
	case schema.IsList():
		g.writeListFieldFromPlutusDataInline(fieldName, schema, index)
	case schema.IsMap():
		g.writeLine(fmt.Sprintf("// TODO: Map deserialization for %s", fieldName))
	case schema.IsBoolean():
		g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].Constr == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected constructor for bool, got %%s", plutusDataTypeString(pd.Constr.Fields[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.Constr.Fields[%d].Constr.Index == 1", fieldName, index))
	default:
		// Check if it might be an enum
		g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.Constr.Fields[%d]); err != nil {", fieldName, index))
		g.indentInc()
		g.writeLine("return err")
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeListFieldFromPlutusData(fieldName, refName string, index int) {
	// Extract inner type from List$Type
	inner := strings.TrimPrefix(refName, "List$")
	inner = strings.ReplaceAll(inner, "~1", "/")

	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].List == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("field %s: expected list")`, fieldName))
	g.indentDec()
	g.writeLine("}")

	goType := g.refToGoType(inner)
	g.writeLine(fmt.Sprintf("v.%s = make([]%s, len(pd.Constr.Fields[%d].List))", fieldName, goType, index))
	g.writeLine(fmt.Sprintf("for i, item := range pd.Constr.Fields[%d].List {", index))
	g.indentInc()

	switch inner {
	case "Int":
		g.writeLine("if item.Integer == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected integer, got %%s", plutusDataTypeString(item))`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
	case "ByteArray":
		g.writeLine("if item.ByteString == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected bytes, got %%s", plutusDataTypeString(item))`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
	case "Bool":
		g.writeLine("if item.Constr == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected bool constructor, got %%s", plutusDataTypeString(item))`, fieldName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s[i] = item.Constr.Index == 1", fieldName))
	default:
		if g.isPrimitiveWrapper(inner, "bytes") {
			g.writeLine("if item.ByteString == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected bytes, got %%s", plutusDataTypeString(item))`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
		} else if g.isPrimitiveWrapper(inner, "integer") {
			g.writeLine("if item.Integer == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: list item expected integer, got %%s", plutusDataTypeString(item))`, fieldName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
		} else if defSchema, ok := g.bp.Definitions[inner]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
			// Check if it's an enum (multi-constructor, not single-constructor)
			typeName := g.normalizeTypeName(inner)
			g.writeLine(fmt.Sprintf("itemVal, err := %sFromPlutusData(item)", typeName))
			g.writeLine("if err != nil {")
			g.indentInc()
			g.writeLine("return err")
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s[i] = itemVal", fieldName))
		} else {
			g.writeLine(fmt.Sprintf("if err := v.%s[i].FromPlutusData(item); err != nil {", fieldName))
			g.indentInc()
			g.writeLine("return err")
			g.indentDec()
			g.writeLine("}")
		}
	}

	g.indentDec()
	g.writeLine("}")
}

func (g *Generator) writeListFieldFromPlutusDataInline(fieldName string, schema *Schema, index int) {
	g.writeLine(fmt.Sprintf("if pd.Constr.Fields[%d].List == nil {", index))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("field %s: expected list")`, fieldName))
	g.indentDec()
	g.writeLine("}")

	if len(schema.Items) > 0 && schema.Items.Single() != nil {
		itemSchema := schema.Items.Single()
		goType := g.schemaToGoType(itemSchema)
		g.writeLine(fmt.Sprintf("v.%s = make([]%s, len(pd.Constr.Fields[%d].List))", fieldName, goType, index))
		g.writeLine(fmt.Sprintf("for i, item := range pd.Constr.Fields[%d].List {", index))
		g.indentInc()

		switch {
		case itemSchema.IsRef():
			refName := itemSchema.RefName()
			switch refName {
			case "Int":
				g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
			case "ByteArray":
				g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
			case "Bool":
				g.writeLine(fmt.Sprintf("v.%s[i] = item.Constr != nil && item.Constr.Index == 1", fieldName))
			default:
				if g.isPrimitiveWrapper(refName, "bytes") {
					g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
				} else if g.isPrimitiveWrapper(refName, "integer") {
					g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
				} else if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
					typeName := g.normalizeTypeName(refName)
					g.writeLine(fmt.Sprintf("itemVal, err := %sFromPlutusData(item)", typeName))
					g.writeLine("if err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine(fmt.Sprintf("v.%s[i] = itemVal", fieldName))
				} else {
					g.writeLine(fmt.Sprintf("if err := v.%s[i].FromPlutusData(item); err != nil {", fieldName))
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
				}
			}
		case itemSchema.IsInteger():
			g.writeLine(fmt.Sprintf("v.%s[i] = item.Integer", fieldName))
		case itemSchema.IsBytes():
			g.writeLine(fmt.Sprintf("v.%s[i] = item.ByteString", fieldName))
		default:
			g.writeLine(fmt.Sprintf("if err := v.%s[i].FromPlutusData(item); err != nil {", fieldName))
			g.indentInc()
			g.writeLine("return err")
			g.indentDec()
			g.writeLine("}")
		}

		g.indentDec()
		g.writeLine("}")
	} else {
		g.writeLine(fmt.Sprintf("// TODO: List deserialization for %s", fieldName))
	}
}

func (g *Generator) writeEnumType(name string, schema *Schema) error {
	// Write interface
	methodName := fmt.Sprintf("is%s", name)
	g.writeLine(fmt.Sprintf("// %s is an enum type with multiple constructors.", name))
	g.writeLine(fmt.Sprintf("type %s interface {", name))
	g.indentInc()
	g.writeLine(fmt.Sprintf("%s()", methodName))
	g.writeLine("ToPlutusData() (PlutusData, error)")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Write FromPlutusData function for the enum
	g.writeEnumFromPlutusData(name, schema)

	// Write variant structs
	for i, variant := range schema.AnyOf {
		variantName := name + g.toGoIdentifier(variant.Title)
		constrIndex := i
		if variant.Index != nil {
			constrIndex = *variant.Index
		}

		if len(variant.Fields) == 0 {
			// Empty struct for enum variants without fields
			g.writeLine(fmt.Sprintf("// %s is a variant of %s.", variantName, name))
			g.writeLine(fmt.Sprintf("type %s struct{}", variantName))
			g.writeLine("")
			g.writeLine(fmt.Sprintf("func (%s) %s() {}", variantName, methodName))
			g.writeLine("")

			// ToPlutusData
			g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", variantName))
			g.indentInc()
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d), nil", constrIndex))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("")

			// FromPlutusData
			g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", variantName))
			g.indentInc()
			g.writeLine("if pd.Constr == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, variantName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("if pd.Constr.Index != %d {", constrIndex))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong constructor index for %s: expected %d, got %%d", pd.Constr.Index)`, variantName, constrIndex))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("return nil")
			g.indentDec()
			g.writeLine("}")
			g.writeLine("")

		} else if len(variant.Fields) == 1 && variant.Fields[0].Title == "" {
			// Single unnamed field - wrapper type
			fieldType := g.schemaToGoType(&variant.Fields[0])
			g.writeLine(fmt.Sprintf("// %s is a variant of %s with a single value.", variantName, name))
			g.writeLine(fmt.Sprintf("type %s struct {", variantName))
			g.indentInc()
			g.writeLine(fmt.Sprintf("Value %s", fieldType))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("")
			g.writeLine(fmt.Sprintf("func (%s) %s() {}", variantName, methodName))
			g.writeLine("")

			// Write ToPlutusData/FromPlutusData for wrapper
			g.writeWrapperToPlutusData(variantName, &variant.Fields[0], constrIndex)
			g.writeWrapperFromPlutusData(variantName, &variant.Fields[0], constrIndex)
		} else {
			// Struct with named fields
			g.writeLine(fmt.Sprintf("// %s is a variant of %s.", variantName, name))
			if err := g.writeStructType(variantName, &variant, constrIndex); err != nil {
				return err
			}
			g.writeLine(fmt.Sprintf("func (%s) %s() {}", variantName, methodName))
			g.writeLine("")
		}
	}

	return nil
}

func (g *Generator) writeEnumFromPlutusData(name string, schema *Schema) {
	g.writeLine(fmt.Sprintf("// %sFromPlutusData decodes a %s from PlutusData.", name, name))
	g.writeLine(fmt.Sprintf("func %sFromPlutusData(pd PlutusData) (%s, error) {", name, name))
	g.indentInc()
	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return nil, errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
	g.writeLine("switch pd.Constr.Index {")

	for i, variant := range schema.AnyOf {
		constrIndex := i
		if variant.Index != nil {
			constrIndex = *variant.Index
		}
		variantName := name + g.toGoIdentifier(variant.Title)
		g.writeLine(fmt.Sprintf("case %d:", constrIndex))
		g.indentInc()
		g.writeLine(fmt.Sprintf("var v %s", variantName))
		g.writeLine("if err := v.FromPlutusData(pd); err != nil {")
		g.indentInc()
		g.writeLine("return nil, err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("return v, nil")
		g.indentDec()
	}

	g.writeLine("default:")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return nil, fmt.Errorf("unknown constructor index for %s: got %%d", pd.Constr.Index)`, name))
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeTupleType(name string, schema *Schema) error {
	g.writeLine(fmt.Sprintf("// %s represents a tuple type.", name))
	g.writeLine(fmt.Sprintf("type %s struct {", name))
	g.indentInc()

	// Generate fields
	for i, item := range schema.Items {
		fieldName := fmt.Sprintf("Field%d", i)
		goType := g.schemaToGoType(item)
		g.writeLine(fmt.Sprintf("%s %s", fieldName, goType))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine(fmt.Sprintf("items := make([]PlutusData, %d)", len(schema.Items)))

	for i, item := range schema.Items {
		fieldName := fmt.Sprintf("Field%d", i)
		g.writeTupleFieldToPlutusData(fieldName, item, i)
	}

	g.writeLine("return NewListPlutusData(items...), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.List == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected list for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("if len(pd.List) != %d {", len(schema.Items)))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong number of items for %s: expected %d, got %%d", len(pd.List))`, name, len(schema.Items)))
	g.indentDec()
	g.writeLine("}")

	for i, item := range schema.Items {
		fieldName := fmt.Sprintf("Field%d", i)
		g.writeTupleFieldFromPlutusData(fieldName, item, i)
	}

	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	return nil
}

func (g *Generator) writeListTypeAlias(name string, schema *Schema) error {
	// Get the inner type
	innerSchema := schema.Items.Single()
	if innerSchema == nil {
		return fmt.Errorf("list type %s has no inner type", name)
	}

	innerGoType := g.schemaToGoType(innerSchema)

	g.writeLine(fmt.Sprintf("// %s represents a list of %s.", name, innerGoType))
	g.writeLine(fmt.Sprintf("type %s []%s", name, innerGoType))
	g.writeLine("")

	// ToPlutusData
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()
	g.writeLine("items := make([]PlutusData, len(v))")
	g.writeLine("for i, item := range v {")
	g.indentInc()
	g.writeListAliasItemToPlutusData(innerSchema)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return NewListPlutusData(items...), nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// FromPlutusData
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()
	g.writeLine("if pd.List == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected list for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("*v = make(%s, len(pd.List))", name))
	g.writeLine("for i, item := range pd.List {")
	g.indentInc()
	g.writeListAliasItemFromPlutusData(innerSchema, name)
	g.indentDec()
	g.writeLine("}")
	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	return nil
}

func (g *Generator) writeListAliasItemToPlutusData(innerSchema *Schema) {
	switch {
	case innerSchema.IsRef():
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("items[i] = NewIntPlutusData(item)")
		case "ByteArray":
			g.writeLine("items[i] = NewBytesPlutusData(item)")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("items[i] = NewBytesPlutusData(item)")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("items[i] = NewIntPlutusData(item)")
			} else {
				g.writeLine("pd, err := item.ToPlutusData()")
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return PlutusData{}, err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine("items[i] = pd")
			}
		}
	case innerSchema.IsInteger():
		g.writeLine("items[i] = NewIntPlutusData(item)")
	case innerSchema.IsBytes():
		g.writeLine("items[i] = NewBytesPlutusData(item)")
	default:
		g.writeLine("pd, err := item.ToPlutusData()")
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine("return PlutusData{}, err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("items[i] = pd")
	}
}

func (g *Generator) writeListAliasItemFromPlutusData(innerSchema *Schema, listName string) {
	switch {
	case innerSchema.IsRef():
		refName := innerSchema.RefName()
		switch refName {
		case "Int":
			g.writeLine("if item.Integer == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected integer, got %%s", plutusDataTypeString(item))`, listName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("(*v)[i] = item.Integer")
		case "ByteArray":
			g.writeLine("if item.ByteString == nil {")
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected bytes, got %%s", plutusDataTypeString(item))`, listName))
			g.indentDec()
			g.writeLine("}")
			g.writeLine("(*v)[i] = item.ByteString")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("if item.ByteString == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected bytes, got %%s", plutusDataTypeString(item))`, listName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("(*v)[i] = item.ByteString")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if item.Integer == nil {")
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected integer, got %%s", plutusDataTypeString(item))`, listName))
				g.indentDec()
				g.writeLine("}")
				g.writeLine("(*v)[i] = item.Integer")
			} else {
				goType := g.refToGoType(refName)
				// Check if it's an enum type
				unescaped := g.unescapeRef(refName)
				if def, ok := g.bp.Definitions[unescaped]; ok && def.IsEnum() {
					factoryFunc := goType + "FromPlutusData"
					g.writeLine(fmt.Sprintf("val, err := %s(item)", factoryFunc))
					g.writeLine("if err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine("(*v)[i] = val")
				} else {
					g.writeLine(fmt.Sprintf("var val %s", goType))
					g.writeLine("if err := val.FromPlutusData(item); err != nil {")
					g.indentInc()
					g.writeLine("return err")
					g.indentDec()
					g.writeLine("}")
					g.writeLine("(*v)[i] = val")
				}
			}
		}
	case innerSchema.IsInteger():
		g.writeLine("if item.Integer == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected integer, got %%s", plutusDataTypeString(item))`, listName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("(*v)[i] = item.Integer")
	case innerSchema.IsBytes():
		g.writeLine("if item.ByteString == nil {")
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("%s: list item expected bytes, got %%s", plutusDataTypeString(item))`, listName))
		g.indentDec()
		g.writeLine("}")
		g.writeLine("(*v)[i] = item.ByteString")
	default:
		g.writeLine("var val " + g.schemaToGoType(innerSchema))
		g.writeLine("if err := val.FromPlutusData(item); err != nil {")
		g.indentInc()
		g.writeLine("return err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine("(*v)[i] = val")
	}
}

func (g *Generator) writeTupleFieldToPlutusData(fieldName string, item *Schema, index int) {
	switch {
	case item.IsRef():
		refName := item.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("items[%d] = NewIntPlutusData(v.%s)", index, fieldName))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("items[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("items[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("items[%d] = NewIntPlutusData(v.%s)", index, fieldName))
			} else {
				g.writeLine(fmt.Sprintf("item%d, err := v.%s.ToPlutusData()", index, fieldName))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return PlutusData{}, err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("items[%d] = item%d", index, index))
			}
		}
	case item.IsInteger():
		g.writeLine(fmt.Sprintf("items[%d] = NewIntPlutusData(v.%s)", index, fieldName))
	case item.IsBytes():
		g.writeLine(fmt.Sprintf("items[%d] = NewBytesPlutusData(v.%s)", index, fieldName))
	default:
		g.writeLine(fmt.Sprintf("item%d, err := v.%s.ToPlutusData()", index, fieldName))
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine("return PlutusData{}, err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("items[%d] = item%d", index, index))
	}
}

func (g *Generator) writeTupleFieldFromPlutusData(fieldName string, item *Schema, index int) {
	switch {
	case item.IsRef():
		refName := item.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("if pd.List[%d].Integer == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].Integer", fieldName, index))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("if pd.List[%d].ByteString == nil {", index))
			g.indentInc()
			g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
			g.indentDec()
			g.writeLine("}")
			g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].ByteString", fieldName, index))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("if pd.List[%d].ByteString == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].ByteString", fieldName, index))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("if pd.List[%d].Integer == nil {", index))
				g.indentInc()
				g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].Integer", fieldName, index))
			} else {
				g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.List[%d]); err != nil {", fieldName, index))
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
			}
		}
	case item.IsInteger():
		g.writeLine(fmt.Sprintf("if pd.List[%d].Integer == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected integer, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].Integer", fieldName, index))
	case item.IsBytes():
		g.writeLine(fmt.Sprintf("if pd.List[%d].ByteString == nil {", index))
		g.indentInc()
		g.writeLine(fmt.Sprintf(`return fmt.Errorf("field %s: expected bytes, got %%s", plutusDataTypeString(pd.List[%d]))`, fieldName, index))
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("v.%s = pd.List[%d].ByteString", fieldName, index))
	default:
		g.writeLine(fmt.Sprintf("if err := v.%s.FromPlutusData(pd.List[%d]); err != nil {", fieldName, index))
		g.indentInc()
		g.writeLine("return err")
		g.indentDec()
		g.writeLine("}")
	}
}

func (g *Generator) writeWrapperToPlutusData(name string, field *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v %s) ToPlutusData() (PlutusData, error) {", name))
	g.indentInc()

	switch {
	case field.IsRef():
		refName := field.RefName()
		switch refName {
		case "Int":
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewIntPlutusData(v.Value)), nil", constrIndex))
		case "ByteArray":
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewBytesPlutusData(v.Value)), nil", constrIndex))
		case "Data":
			// Data type is raw PlutusData - pass through directly
			g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, v.Value), nil", constrIndex))
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewBytesPlutusData(v.Value)), nil", constrIndex))
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewIntPlutusData(v.Value)), nil", constrIndex))
			} else {
				g.writeLine("inner, err := v.Value.ToPlutusData()")
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return PlutusData{}, err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, inner), nil", constrIndex))
			}
		}
	case field.IsInteger():
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewIntPlutusData(v.Value)), nil", constrIndex))
	case field.IsBytes():
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, NewBytesPlutusData(v.Value)), nil", constrIndex))
	default:
		g.writeLine("inner, err := v.Value.ToPlutusData()")
		g.writeLine("if err != nil {")
		g.indentInc()
		g.writeLine("return PlutusData{}, err")
		g.indentDec()
		g.writeLine("}")
		g.writeLine(fmt.Sprintf("return NewConstrPlutusData(%d, inner), nil", constrIndex))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

func (g *Generator) writeWrapperFromPlutusData(name string, field *Schema, constrIndex int) {
	g.writeLine(fmt.Sprintf("func (v *%s) FromPlutusData(pd PlutusData) error {", name))
	g.indentInc()

	g.writeLine("if pd.Constr == nil {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return errors.New("expected constructor for %s")`, name))
	g.indentDec()
	g.writeLine("}")
	g.writeLine(fmt.Sprintf("if pd.Constr.Index != %d {", constrIndex))
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong constructor index for %s: expected %d, got %%d", pd.Constr.Index)`, name, constrIndex))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("if len(pd.Constr.Fields) != 1 {")
	g.indentInc()
	g.writeLine(fmt.Sprintf(`return fmt.Errorf("wrong number of fields for %s: expected 1, got %%d", len(pd.Constr.Fields))`, name))
	g.indentDec()
	g.writeLine("}")

	switch {
	case field.IsRef():
		refName := field.RefName()
		switch refName {
		case "Int":
			g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
			g.indentInc()
			g.writeLine(`return fmt.Errorf("expected integer, got %s", plutusDataTypeString(pd.Constr.Fields[0]))`)
			g.indentDec()
			g.writeLine("}")
			g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
		case "ByteArray":
			g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
			g.indentInc()
			g.writeLine(`return fmt.Errorf("expected bytes, got %s", plutusDataTypeString(pd.Constr.Fields[0]))`)
			g.indentDec()
			g.writeLine("}")
			g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
		case "Data":
			// Data type is raw PlutusData - store directly
			g.writeLine("v.Value = pd.Constr.Fields[0]")
		default:
			if g.isPrimitiveWrapper(refName, "bytes") {
				g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
				g.indentInc()
				g.writeLine(`return fmt.Errorf("expected bytes, got %s", plutusDataTypeString(pd.Constr.Fields[0]))`)
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
			} else if g.isPrimitiveWrapper(refName, "integer") {
				g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
				g.indentInc()
				g.writeLine(`return fmt.Errorf("expected integer, got %s", plutusDataTypeString(pd.Constr.Fields[0]))`)
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
			} else if defSchema, ok := g.bp.Definitions[g.unescapeRef(refName)]; ok && defSchema.IsEnum() && !defSchema.IsSingleConstructor() {
				// Enum type - use factory function
				typeName := g.normalizeTypeName(refName)
				g.writeLine(fmt.Sprintf("innerVal, err := %sFromPlutusData(pd.Constr.Fields[0])", typeName))
				g.writeLine("if err != nil {")
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
				g.writeLine("v.Value = innerVal")
			} else {
				g.writeLine("if err := v.Value.FromPlutusData(pd.Constr.Fields[0]); err != nil {")
				g.indentInc()
				g.writeLine("return err")
				g.indentDec()
				g.writeLine("}")
			}
		}
	case field.IsInteger():
		g.writeLine("if pd.Constr.Fields[0].Integer == nil {")
		g.indentInc()
		g.writeLine(`return fmt.Errorf("expected integer, got %s", plutusDataTypeString(pd.Constr.Fields[0]))`)
		g.indentDec()
		g.writeLine("}")
		g.writeLine("v.Value = pd.Constr.Fields[0].Integer")
	case field.IsBytes():
		g.writeLine("if pd.Constr.Fields[0].ByteString == nil {")
		g.indentInc()
		g.writeLine(`return fmt.Errorf("expected bytes, got %s", plutusDataTypeString(pd.Constr.Fields[0]))`)
		g.indentDec()
		g.writeLine("}")
		g.writeLine("v.Value = pd.Constr.Fields[0].ByteString")
	default:
		g.writeLine("if err := v.Value.FromPlutusData(pd.Constr.Fields[0]); err != nil {")
		g.indentInc()
		g.writeLine("return err")
		g.indentDec()
		g.writeLine("}")
	}

	g.writeLine("return nil")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

// schemaToGoType converts a schema to a Go type string.
func (g *Generator) schemaToGoType(schema *Schema) string {
	switch {
	case schema.IsRef():
		return g.refToGoType(schema.RefName())
	case schema.IsInteger():
		return "*big.Int"
	case schema.IsBytes():
		return "[]byte"
	case schema.IsList():
		if len(schema.Items) > 0 {
			if schema.Items.IsTuple() {
				return "[]interface{}"
			}
			itemType := g.schemaToGoType(schema.Items.Single())
			return "[]" + itemType
		}
		return "[]interface{}"
	case schema.IsMap():
		keyType := "string"
		if schema.Keys != nil {
			kt := g.schemaToGoType(schema.Keys)
			// []byte can't be a map key in Go, keep as string
			if kt != "[]byte" {
				keyType = kt
			}
		}
		valueType := "interface{}"
		if schema.Values != nil {
			valueType = g.schemaToGoType(schema.Values)
		}
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	case schema.IsBoolean():
		return "bool"
	case schema.IsUnit():
		return "struct{}"
	case schema.IsOption():
		inner := schema.OptionInnerType()
		if inner != nil {
			innerGoType := g.schemaToGoType(inner)
			// Don't add pointer if inner type is already a pointer or interface
			if strings.HasPrefix(innerGoType, "*") || innerGoType == "interface{}" {
				return innerGoType
			}
			return "*" + innerGoType
		}
		return "interface{}"
	case schema.IsEnum():
		return "interface{}"
	case schema.IsOpaque() || schema.IsEmpty():
		return "interface{}" // Any Plutus data
	default:
		return "interface{}"
	}
}

func (g *Generator) refToGoType(refName string) string {
	switch refName {
	case "Int":
		return "*big.Int"
	case "ByteArray":
		return "[]byte"
	case "Bool":
		return "bool"
	case "Data":
		return "PlutusData"
	case "Void":
		return "struct{}"
	default:
		if strings.HasPrefix(refName, "List$") {
			// Extract inner type
			inner := strings.TrimPrefix(refName, "List$")
			inner = strings.ReplaceAll(inner, "~1", "/")
			return "[]" + g.refToGoType(inner)
		}
		if strings.HasPrefix(refName, "Option$") {
			// Option types - use pointer to inner type
			inner := strings.TrimPrefix(refName, "Option$")
			inner = strings.ReplaceAll(inner, "~1", "/")
			innerGoType := g.refToGoType(inner)

			// Don't add pointer if inner type is already a pointer or interface
			if strings.HasPrefix(innerGoType, "*") || innerGoType == "interface{}" {
				return innerGoType
			}
			// Check if inner type is an enum (interface)
			unescaped := g.unescapeRef(inner)
			if def, ok := g.bp.Definitions[unescaped]; ok && def.IsEnum() && !def.IsSingleConstructor() {
				return innerGoType // Enum is an interface, already nullable
			}
			return "*" + innerGoType
		}
		if strings.HasPrefix(refName, "Pairs$") {
			return g.pairsToGoType(refName)
		}

		// Check if the referenced type is actually a primitive wrapper
		unescaped := g.unescapeRef(refName)
		if def, ok := g.bp.Definitions[unescaped]; ok {
			if def.IsBytes() {
				return "[]byte"
			}
			if def.IsInteger() {
				return "*big.Int"
			}
		}

		// All other types - normalize the name
		return g.normalizeTypeName(refName)
	}
}

func (g *Generator) pairsToGoType(refName string) string {
	inner := strings.TrimPrefix(refName, "Pairs$")
	inner = strings.ReplaceAll(inner, "~1", "/")
	parts := strings.SplitN(inner, "_", 2)
	if len(parts) != 2 {
		return "map[string]interface{}"
	}
	keyType := g.refToGoType(parts[0])
	// []byte can't be a map key in Go, keep as string
	if keyType == "[]byte" {
		keyType = "string"
	}
	valueType := g.refToGoType(parts[1])
	return fmt.Sprintf("map[%s]%s", keyType, valueType)
}

// Helper functions

func (g *Generator) normalizeTypeName(name string) string {
	// Handle prefixes like Option$, List$, etc.
	// Examples:
	//   Option$string_validator/SimpleString -> OptionStringValidatorSimpleString
	//   Option$custom/Credential -> OptionCustomCredential
	//   v0_3/types/Settings -> V03TypesSettings
	//   Option$Int -> OptionInt
	//   List$Int -> ListInt

	// First, unescape URL-encoded characters (~1 = /, ~0 = ~)
	name = strings.ReplaceAll(name, "~1", "/")
	name = strings.ReplaceAll(name, "~0", "~")

	// Check if there's a $ in the name (prefix type)
	if idx := strings.Index(name, "$"); idx >= 0 {
		prefix := name[:idx]
		rest := name[idx+1:]
		// Get the inner type name
		innerName := g.normalizeTypeName(rest)
		return g.toGoIdentifier(prefix) + innerName
	}

	// Include the full path to avoid name collisions
	// e.g., v0_3/types/Settings -> V03TypesSettings
	parts := strings.Split(name, "/")
	var result strings.Builder
	for _, part := range parts {
		result.WriteString(g.toGoIdentifier(part))
	}
	return result.String()
}

func (g *Generator) normalizeFieldName(name string, index int) string {
	if name == "" {
		return fmt.Sprintf("Field%d", index)
	}
	return g.toGoIdentifier(name)
}

func (g *Generator) toGoIdentifier(s string) string {
	if s == "" {
		return ""
	}
	// Remove or replace characters invalid in Go identifiers
	// Valid: letters, digits, underscore (but can't start with digit)
	s = strings.ReplaceAll(s, "/", "_")
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, " ", "_")
	s = g.snakeToCamel(s)
	runes := []rune(s)
	if len(runes) > 0 {
		runes[0] = unicode.ToUpper(runes[0])
	}
	return string(runes)
}

func (g *Generator) snakeToCamel(s string) string {
	if !strings.Contains(s, "_") {
		if len(s) > 0 {
			return strings.ToUpper(s[:1]) + s[1:]
		}
		return s
	}
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return strings.Join(parts, "")
}

func (g *Generator) unescapeRef(ref string) string {
	// Handle JSON Pointer escaping: ~1 = /, ~0 = ~
	ref = strings.ReplaceAll(ref, "~1", "/")
	ref = strings.ReplaceAll(ref, "~0", "~")
	return ref
}

func (g *Generator) isStandardTypeName(name string) bool {
	// Only skip truly primitive types that don't have definitions
	switch name {
	case "Int", "ByteArray", "Data", "Void", "Bool":
		return true
	default:
		return false
	}
}

// isPrimitiveWrapper checks if the referenced type is a primitive wrapper (e.g., PolicyId -> bytes)
func (g *Generator) isPrimitiveWrapper(refName string, primitiveType string) bool {
	unescaped := g.unescapeRef(refName)
	if def, ok := g.bp.Definitions[unescaped]; ok {
		switch primitiveType {
		case "bytes":
			return def.IsBytes()
		case "integer":
			return def.IsInteger()
		}
	}
	return false
}

// Output helpers

func (g *Generator) writeLine(s string) {
	for i := 0; i < g.indent; i++ {
		g.buf.WriteString("\t")
	}
	g.buf.WriteString(s)
	g.buf.WriteString("\n")
}

func (g *Generator) indentInc() {
	g.indent++
}

func (g *Generator) indentDec() {
	if g.indent > 0 {
		g.indent--
	}
}
