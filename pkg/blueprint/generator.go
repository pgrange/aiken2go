package blueprint

import (
	"fmt"
	"sort"
	"strings"
	"unicode"
)

// GeneratorOptions configures the code generator.
type GeneratorOptions struct {
	// PackageName is the Go package name for generated code.
	PackageName string
	// WithTrace includes trace-enabled script variants.
	WithTrace bool
}

// Generator produces Go source code from a Blueprint.
type Generator struct {
	bp         *Blueprint
	traceBp    *Blueprint
	opts       GeneratorOptions
	buf        strings.Builder
	indent     int
	indentSize int
	generated  map[string]bool // track which types have been generated
}

// NewGenerator creates a new code generator.
func NewGenerator(bp *Blueprint, traceBp *Blueprint, opts GeneratorOptions) *Generator {
	if opts.PackageName == "" {
		opts.PackageName = "contracts"
	}
	return &Generator{
		bp:         bp,
		traceBp:    traceBp,
		opts:       opts,
		indentSize: 1, // use tabs
		generated:  make(map[string]bool),
	}
}

// Generate produces Go source code from the blueprint.
func (g *Generator) Generate() (string, error) {
	g.writeHeader()
	g.writeImports()
	g.writeLine("")

	// Generate type definitions
	if err := g.writeTypeDefinitions(); err != nil {
		return "", err
	}

	// Generate validators
	g.writeValidators()

	return g.buf.String(), nil
}

func (g *Generator) writeHeader() {
	g.writeLine("// Code generated by aiken2go. DO NOT EDIT.")
	g.writeLine(fmt.Sprintf("// Source: %s", g.bp.Preamble.Title))
	g.writeLine(fmt.Sprintf("// Plutus version: %s", g.bp.Preamble.PlutusVersion))
	g.writeLine("")
	g.writeLine(fmt.Sprintf("package %s", g.opts.PackageName))
}

func (g *Generator) writeImports() {
	g.writeLine("")
	g.writeLine("import (")
	g.indentInc()
	g.writeLine(`"math/big"`)
	g.indentDec()
	g.writeLine(")")
}

func (g *Generator) writeTypeDefinitions() error {
	// Sort definition names for deterministic output
	names := make([]string, 0, len(g.bp.Definitions))
	for name := range g.bp.Definitions {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		schema := g.bp.Definitions[name]
		if g.isStandardTypeName(name) {
			continue
		}
		// Skip List$ and Pairs$ types as they're handled inline
		if strings.HasPrefix(name, "List$") || strings.HasPrefix(name, "Pairs$") {
			continue
		}
		if err := g.writeTypeDef(name, schema); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) writeTypeDef(name string, schema *Schema) error {
	goName := g.normalizeTypeName(name)

	// Skip if already generated
	if g.generated[goName] {
		return nil
	}
	g.generated[goName] = true

	// Add documentation
	if schema.Description != "" {
		g.writeLine(fmt.Sprintf("// %s %s", goName, schema.Description))
	}

	// Handle different schema types
	switch {
	case schema.IsBoolean():
		// Skip - use native bool
		return nil
	case schema.IsUnit():
		// Generate empty struct for Unit/Void
		g.writeLine(fmt.Sprintf("type %s struct{}", goName))
		g.writeLine("")
		return nil
	case schema.IsOption():
		// Skip - use pointer type inline
		return nil
	case schema.IsSingleConstructor():
		// Single constructor - generate struct
		return g.writeStructType(goName, &schema.AnyOf[0])
	case schema.IsEnum():
		// Multiple constructors - generate interface + variants
		return g.writeEnumType(goName, schema)
	case schema.IsConstructor():
		// Direct constructor
		return g.writeStructType(goName, schema)
	default:
		// Primitive or reference - skip (handled inline)
		return nil
	}
}

func (g *Generator) writeStructType(name string, schema *Schema) error {
	g.writeLine(fmt.Sprintf("type %s struct {", name))
	g.indentInc()

	for i, field := range schema.Fields {
		fieldName := g.normalizeFieldName(field.Title, i)
		fieldType := g.schemaToGoType(&field)
		cborTag := fmt.Sprintf("`cbor:\"%d,keyasint\"`", i)
		g.writeLine(fmt.Sprintf("%s %s %s", fieldName, fieldType, cborTag))
	}

	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
	return nil
}

func (g *Generator) writeEnumType(name string, schema *Schema) error {
	// Write interface
	methodName := fmt.Sprintf("is%s", name)
	g.writeLine(fmt.Sprintf("type %s interface {", name))
	g.indentInc()
	g.writeLine(fmt.Sprintf("%s()", methodName))
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Write variant structs
	for _, variant := range schema.AnyOf {
		variantName := name + g.toGoIdentifier(variant.Title)

		if len(variant.Fields) == 0 {
			// Empty struct for enum variants without fields
			g.writeLine(fmt.Sprintf("type %s struct{}", variantName))
		} else if len(variant.Fields) == 1 && variant.Fields[0].Title == "" {
			// Single unnamed field - wrapper type
			fieldType := g.schemaToGoType(&variant.Fields[0])
			cborTag := "`cbor:\"0,keyasint\"`"
			g.writeLine(fmt.Sprintf("type %s struct {", variantName))
			g.indentInc()
			g.writeLine(fmt.Sprintf("Value %s %s", fieldType, cborTag))
			g.indentDec()
			g.writeLine("}")
		} else {
			// Struct with named fields
			g.writeLine(fmt.Sprintf("type %s struct {", variantName))
			g.indentInc()
			for i, field := range variant.Fields {
				fieldName := g.normalizeFieldName(field.Title, i)
				fieldType := g.schemaToGoType(&field)
				cborTag := fmt.Sprintf("`cbor:\"%d,keyasint\"`", i)
				g.writeLine(fmt.Sprintf("%s %s %s", fieldName, fieldType, cborTag))
			}
			g.indentDec()
			g.writeLine("}")
		}

		// Write interface implementation
		g.writeLine(fmt.Sprintf("func (%s) %s() {}", variantName, methodName))
		g.writeLine("")
	}

	return nil
}

func (g *Generator) writeValidators() {
	for _, v := range g.bp.Validators {
		g.writeValidator(&v)
	}
}

func (g *Generator) writeValidator(v *Validator) {
	name := g.validatorName(v.Title)

	// Find traced variant if available
	var tracedCode string
	if g.traceBp != nil {
		for _, tv := range g.traceBp.Validators {
			if tv.Title == v.Title {
				tracedCode = tv.CompiledCode
				break
			}
		}
	}

	// Write struct
	g.writeLine(fmt.Sprintf("// %s validator for %s", name, v.Title))
	g.writeLine(fmt.Sprintf("type %s struct {", name))
	g.indentInc()
	g.writeLine("Script     string // Compiled CBOR hex")
	g.writeLine("ScriptHash string")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")

	// Write constructor
	g.writeValidatorConstructor(v, name, tracedCode)
}

func (g *Generator) writeValidatorConstructor(v *Validator, name, tracedCode string) {
	// Build parameter list
	params := make([]string, 0)
	for _, p := range v.Parameters {
		paramName := g.toGoIdentifier(p.Title)
		if paramName == "" {
			paramName = "param"
		}
		paramName = strings.ToLower(paramName[:1]) + paramName[1:]
		paramType := g.schemaToGoType(&p.Schema)
		params = append(params, fmt.Sprintf("%s %s", paramName, paramType))
	}

	// Add trace parameter if we have traced code
	if tracedCode != "" {
		params = append(params, "trace bool")
	}

	paramStr := strings.Join(params, ", ")

	g.writeLine(fmt.Sprintf("func New%s(%s) *%s {", name, paramStr, name))
	g.indentInc()

	// TODO: For parameterized scripts, we would need UPLC parameter application
	// For now, we just return the base script with a note
	if len(v.Parameters) > 0 {
		g.writeLine("// TODO: Parameter application requires UPLC library")
		g.writeLine("// Parameters are currently ignored - use base script")
	}

	if tracedCode != "" {
		g.writeLine("script := \"\"")
		g.writeLine("if trace {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("script = %q", tracedCode))
		g.indentDec()
		g.writeLine("} else {")
		g.indentInc()
		g.writeLine(fmt.Sprintf("script = %q", v.CompiledCode))
		g.indentDec()
		g.writeLine("}")
	} else {
		g.writeLine(fmt.Sprintf("script := %q", v.CompiledCode))
	}

	g.writeLine(fmt.Sprintf("return &%s{", name))
	g.indentInc()
	g.writeLine("Script:     script,")
	g.writeLine(fmt.Sprintf("ScriptHash: %q,", v.Hash))
	g.indentDec()
	g.writeLine("}")
	g.indentDec()
	g.writeLine("}")
	g.writeLine("")
}

// schemaToGoType converts a schema to a Go type string.
func (g *Generator) schemaToGoType(schema *Schema) string {
	switch {
	case schema.IsRef():
		return g.refToGoType(schema.RefName())
	case schema.IsInteger():
		return "*big.Int"
	case schema.IsBytes():
		return "string" // hex encoded
	case schema.IsList():
		if schema.Items != nil {
			itemType := g.schemaToGoType(schema.Items)
			return "[]" + itemType
		}
		return "[]interface{}"
	case schema.IsMap():
		keyType := "string"
		if schema.Keys != nil {
			keyType = g.schemaToGoType(schema.Keys)
		}
		valueType := "interface{}"
		if schema.Values != nil {
			valueType = g.schemaToGoType(schema.Values)
		}
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	case schema.IsBoolean():
		return "bool"
	case schema.IsUnit():
		return "struct{}"
	case schema.IsOption():
		inner := schema.OptionInnerType()
		if inner != nil {
			return "*" + g.schemaToGoType(inner)
		}
		return "*interface{}"
	case schema.IsEnum():
		// This shouldn't happen for inline types
		return "interface{}"
	case schema.IsOpaque() || schema.IsEmpty():
		return "interface{}" // Any Plutus data
	default:
		return "interface{}"
	}
}

func (g *Generator) refToGoType(refName string) string {
	switch refName {
	case "Int":
		return "*big.Int"
	case "ByteArray":
		return "string"
	case "Data":
		return "interface{}"
	case "Void":
		return "struct{}"
	default:
		// Check for standard Cardano/Aiken types
		if strings.HasPrefix(refName, "cardano/transaction/OutputReference") {
			return "OutputReference"
		}
		if strings.HasPrefix(refName, "cardano/address/Credential") {
			return "Credential"
		}
		if strings.HasPrefix(refName, "cardano/assets/PolicyId") {
			return "string" // PolicyId is bytes/hex
		}
		if strings.HasPrefix(refName, "cardano/assets/AssetName") {
			return "string" // AssetName is bytes/hex
		}
		if strings.HasPrefix(refName, "aiken/crypto/") {
			return "string" // Hashes are bytes/hex
		}
		if strings.HasPrefix(refName, "List$") {
			// Extract inner type
			inner := strings.TrimPrefix(refName, "List$")
			inner = strings.ReplaceAll(inner, "~1", "/")
			return "[]" + g.refToGoType(inner)
		}
		if strings.HasPrefix(refName, "Pairs$") {
			// Map type - extract key/value types
			return g.pairsToGoType(refName)
		}

		// Custom type - normalize the name
		return g.normalizeTypeName(refName)
	}
}

func (g *Generator) pairsToGoType(refName string) string {
	// Parse "Pairs$key_value" format
	inner := strings.TrimPrefix(refName, "Pairs$")
	inner = strings.ReplaceAll(inner, "~1", "/")

	// Find the separator between key and value types
	// The format is "KeyType_ValueType"
	parts := strings.SplitN(inner, "_", 2)
	if len(parts) != 2 {
		return "map[string]interface{}"
	}

	keyType := g.refToGoType(parts[0])
	valueType := g.refToGoType(parts[1])

	return fmt.Sprintf("map[%s]%s", keyType, valueType)
}

// Helper functions for name normalization

func (g *Generator) normalizeTypeName(name string) string {
	// Handle module paths like "types/Payout" -> "Payout"
	// and "sundae/multisig/MultisigScript" -> "MultisigScript"
	parts := strings.Split(name, "/")
	typeName := parts[len(parts)-1]

	// Handle generic types like "List$Int" -> skip
	if strings.Contains(typeName, "$") {
		// For types like "Pairs$cardano/assets/AssetName_Int", extract meaningful name
		parts := strings.Split(typeName, "$")
		if len(parts) > 1 {
			typeName = g.toGoIdentifier(parts[0]) + g.toGoIdentifier(parts[1])
		}
	}

	return g.toGoIdentifier(typeName)
}

func (g *Generator) normalizeFieldName(name string, index int) string {
	if name == "" {
		return fmt.Sprintf("Field%d", index)
	}
	return g.toGoIdentifier(name)
}

func (g *Generator) validatorName(title string) string {
	// Convert "always_true.script.spend" to "AlwaysTrueScriptSpend"
	// Convert "nested/sometimes_true.script.spend" to "NestedSometimesTrueScriptSpend"
	title = strings.ReplaceAll(title, "/", "_")
	parts := strings.Split(title, ".")
	var result strings.Builder
	for _, part := range parts {
		result.WriteString(g.snakeToCamel(part))
	}
	return result.String()
}

func (g *Generator) toGoIdentifier(s string) string {
	if s == "" {
		return ""
	}
	// Convert snake_case to CamelCase and ensure first letter is uppercase
	s = g.snakeToCamel(s)
	// Ensure valid Go identifier
	runes := []rune(s)
	if len(runes) > 0 {
		runes[0] = unicode.ToUpper(runes[0])
	}
	return string(runes)
}

func (g *Generator) snakeToCamel(s string) string {
	// If no underscores, this is already CamelCase - just ensure first letter is uppercase
	if !strings.Contains(s, "_") {
		if len(s) > 0 {
			return strings.ToUpper(s[:1]) + s[1:]
		}
		return s
	}

	// Handle snake_case conversion
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return strings.Join(parts, "")
}

func (g *Generator) isStandardTypeName(name string) bool {
	switch name {
	case "Int", "ByteArray", "Data", "Void":
		return true
	default:
		return strings.HasPrefix(name, "cardano/") ||
			strings.HasPrefix(name, "aiken/") ||
			strings.HasPrefix(name, "List$") ||
			strings.HasPrefix(name, "Pairs$")
	}
}

// Output helpers

func (g *Generator) writeLine(s string) {
	for i := 0; i < g.indent; i++ {
		g.buf.WriteString("\t")
	}
	g.buf.WriteString(s)
	g.buf.WriteString("\n")
}

func (g *Generator) indentInc() {
	g.indent++
}

func (g *Generator) indentDec() {
	if g.indent > 0 {
		g.indent--
	}
}
